
module Backend.SemanticAnalyer where

import Backend.IAST (Program)
import Data.List (intercalate)
import Data.Set (toList, fromList)
import qualified Frontend.LambdaQ.Abs as GeneratedAbstractSyntax
import Text.Parsec.Error (errorMessages)

data SemanticError =
    DuplicatedFunctionName String                     |  -- function names must be unique
    DuplicateFunctionDefinition String                |  -- there should be no duplicated function definition
    DuplicateFunctionDeclaration String               |  -- there should be no duplicated function declaration
    MismatchedFunctionDefinitionAndDeclaration String |  -- function signature in declaration has a definition with a matching signature
    IncorrectNumberOfFunctionArguments String         |  -- number of function arguments for a function call does not exceed number of arguments in signature
    ControlQbitsNotDistinct String                    |  -- control qubits for controlled gates must be distinct
    ControlBitsNotDistinct String                     |  -- control bits for classically controlled gates must be distinct
    ControlAndTargetQbitsNotDistinct String           |  -- for a controlled gate the control and target qubits must be distinct
    InvalidBitValue String                            |  -- the value of a bit must be either 0 or 1
    UnknownGate String                                   -- gate names should be recognized as belonging to the set of supported gates

instance Show SemanticError where
    show (DuplicatedFunctionName err) = "Function name is not unique: " ++ err
    show (DuplicateFunctionDefinition err) = "Function definition is duplicated: "  ++ err
    show (DuplicateFunctionDeclaration err) = "Function declaration is duplicated: "  ++ err
    show (MismatchedFunctionDefinitionAndDeclaration err) = "Function signature in declaration  does not match the signature in definition: " ++ err
    show (IncorrectNumberOfFunctionArguments err) = "Number of function arguments exceeds the number of arguments in signature: " ++ err
    show (ControlQbitsNotDistinct err) = "The control qubits for controlled gate are not distinct: " ++ err
    show (ControlBitsNotDistinct err) = "The control bits for classical controlled gate are not distinct: " ++ err
    show (ControlAndTargetQbitsNotDistinct err) = "The control and target qubits are not distinct: " ++ err
    show (InvalidBitValue err) = "The bit value should be either 0 or 1: " ++ err
    show (UnknownGate err) = "This gate is not supported: " ++ err

performSemanticAnalysis :: GeneratedAbstractSyntax.Program -> Either SemanticError ()
performSemanticAnalysis (GeneratedAbstractSyntax.ProgDef functions) = 
    mapM_ ($ functions) [
        functionNameIsUnique, 
        functionDefinitionsAreUnique, 
        functionDeclarationsAreUnique, 
        functionDeclarationSignaturesMatchDefinitions,
        functionsHaveCorrectNumberOfArguments,
        controlQubitsAreDistinct,
        controlBitsAreDistinct,
        controlAndTargetQubitsAreDistinct,
        bitValuesAreValid,
        gateNamesAreValid
    ]

-- test functions for a given semantic condition and in case of failure append the condition 
-- error messages to a list of existing error messages generated by other invalidated conditions
testCondition :: [GeneratedAbstractSyntax.FunctionDeclaration] -> (GeneratedAbstractSyntax.FunctionDeclaration -> Bool) -> String ->  [String]  -> [String]
testCondition [] _ _ _ = []
testCondition (fun:funs) conditionPredicate conditionErrorMessage previousConditionsErrorMessages = 
    if conditionPredicate fun 
        then 
            testCondition funs conditionPredicate conditionErrorMessage previousConditionsErrorMessages
        else 
            testCondition funs conditionPredicate conditionErrorMessage (conditionErrorMessage:previousConditionsErrorMessages) 

testSemanticsForCondition :: [GeneratedAbstractSyntax.FunctionDeclaration] -> (GeneratedAbstractSyntax.FunctionDeclaration -> Bool) -> SemanticError -> Either SemanticError ()
testSemanticsForCondition functions conditionPredicate semanticError = if null [] then Right () else Left semanticError
  where errors = intercalate ", " $ uniquify $ testCondition functions conditionPredicate (show semanticError) []

functionNameIsUnique :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
functionNameIsUnique functions = testSemanticsForCondition functions conditionIsValid (DuplicatedFunctionName "")
  where
    conditionIsValid function = length (filter (== getFunctionName function) functionNames) == 1
    functionNames = map getFunctionName functions

functionDefinitionsAreUnique :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
functionDefinitionsAreUnique function = undefined

functionDeclarationsAreUnique :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
functionDeclarationsAreUnique function = undefined

functionDeclarationSignaturesMatchDefinitions :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
functionDeclarationSignaturesMatchDefinitions function = undefined

functionsHaveCorrectNumberOfArguments :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
functionsHaveCorrectNumberOfArguments function = undefined

controlQubitsAreDistinct :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
controlQubitsAreDistinct function = undefined

controlBitsAreDistinct :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
controlBitsAreDistinct function = undefined

controlAndTargetQubitsAreDistinct :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
controlAndTargetQubitsAreDistinct function = undefined

bitValuesAreValid :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
bitValuesAreValid function = undefined

gateNamesAreValid :: [GeneratedAbstractSyntax.FunctionDeclaration] -> Either SemanticError ()
gateNamesAreValid function = undefined

-- helper functions
getFunctionName :: GeneratedAbstractSyntax.FunctionDeclaration -> String
getFunctionName (GeneratedAbstractSyntax.FunDecl _ funDef) = fname
  where
    (GeneratedAbstractSyntax.FunDef (GeneratedAbstractSyntax.Var fvar) fargs fbody) = funDef
    ((fline, fcol), fname) = fvar

getFunctionPosition :: GeneratedAbstractSyntax.FunctionDeclaration -> String
getFunctionPosition (GeneratedAbstractSyntax.FunDecl _ funDef) =  "line: " ++ show fline ++  "column: " ++ show fcol
  where
    (GeneratedAbstractSyntax.FunDef (GeneratedAbstractSyntax.Var fvar) fargs fbody) = funDef
    ((fline, fcol), fname) = fvar

uniquify :: Ord a => [a] -> [a]
uniquify lst = toList $ fromList lst