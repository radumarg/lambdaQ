-- This file contain the specification of the for the intermediate abstract syntax tree (IAST).
-- The intermediate abstract syntax tree hase a simpler syntax than the abstract syntax (AST)
-- generated by the parser and is easier to process by the type checker and the code generator:
--   *  functions to be be converted to lambda abstractions 
--   *  introduce De Bruijn indices for bound variables in lambda abstractions
--   *  BNFC generated AST terms to be converted into an intermediate abstract syntax tree terms
module Backend.ASTtoIASTConverter (
  Function(..),
  Gate(..),
  mapProgram,
  Program,
  runAstToIastConverter,
  Term(..),
  Type(..),
) where

import qualified Frontend.LambdaQ.Abs as GeneratedAbstractSyntax
import Frontend.LambdaQ.Print ( printTree )
import Frontend.LambdaQ.Par ( myLexer, pProgram )
import qualified Data.Map


data Type =
   TypeBit             |
   TypeQbit            |
   TypeState           |
   TypeUnitary         |
   TypeNonLinear Type  |
   TypeUnit            |
   Type :->: Type      |
   Type :*: Type       |
   Type :+: Type       |
   Type :**: Integer
  deriving (Eq, Ord, Read, Show)

infixr 1 :->:
infixr 2 :+:
infixr 3 :*:
infixr 4 :**:

data BasisState =
    BasisStateZero   |
    BasisStateOne    |
    BasisStatePlus   |
    BasisStateMinus  |
    BasisStatePlusI  |
    BasisStateMinusI
  deriving (Eq, Ord, Show, Read)

newtype ControlBasisState = CtrlBasisState BasisState
  deriving (Eq, Ord, Show, Read)

data ControlBasisStates = CtrlBasisStates BasisState [BasisState]
  deriving (Eq, Ord, Show, Read)

newtype Angle = Angle Double
  deriving (Eq, Ord, Show, Read)

data Bit = BitZero | BitOne
  deriving (Eq, Ord, Show, Read)

data Gate =
    GateH                      |
    GateX                      |
    GateY                      |
    GateZ                      |
    GateID                     |
    GateXRoot Integer          |
    GateXRootDag Integer       |
    GateYRoot Integer          |
    GateYRootDag Integer       |
    GateZRoot Integer          |
    GateZRootDag Integer       |
    GateS                      |
    GateSDag                   |
    GateT                      |
    GateTDag                   |
    GateSqrtX                  |
    GateSqrtXDag               |
    GateSqrtY                  |
    GateSqrtYDag               |
    GateRxTheta Angle          |
    GateRyTheta Angle          |
    GateRzTheta Angle          |
    GateU1 Angle               |
    GateU2 Angle Angle         |
    GateU3 Angle Angle Angle   |
    GateSwp                    |
    GateSqrtSwp                |
    GateSqrtSwpDag             |
    GateISwp                   |
    GateFSwp                   |
    GateSwpTheta Angle         |
    GateSwpRt Integer          |
    GateSwpRtDag Integer       |
    GateQft Integer            |
    GateQftDag Integer
  deriving (Eq, Ord, Read, Show)

data Term =
    TermBoundVariable Integer                     |
    TermFreeVariable String                       |
    TermIfElse Term Term Term                     |
    TermLetSingle Term Term                       |
    TermLetMultiple Term Term                     |
    TermLetSugarSingle Term Term                  |
    TermLetSugarMultiple Term Term                |
    TermCase Term [Term]                          |
    TermLambda Type Term                          |
    TermFunction String                           |
    TermGate Gate                                 |
    TermQuantumCtrlGate Term BasisState           |
    TermQuantumCtrlsGate [Term] [BasisState]      |
    TermClassicCtrlGate Term Integer              |
    TermClassicCtrlsGate [Term] [Integer]         |
    TermApply Term Term                           |
    TermDollar Term Term                          |
    TermCompose Term Term                         |
    TermNew  (Int, Int)                           |
    TermMeasure (Int, Int)                        |
    TermBasisState BasisState                     |
    TermTuple Term Term                           |
    TermBit Bit                                   |
    TermUnit
  deriving (Eq, Ord, Read, Show)

newtype ControlTerm = CtrlTerm Term
  deriving (Eq, Ord, Show, Read)

data ControlTerms = CtrlTerms Term [Term]
  deriving (Eq, Ord, Show, Read)

data Function = Function String (Int, Int) Type Term
  deriving (Show, Read)

instance Ord Function where
  compare (Function a _ _ _) (Function b _ _ _) = compare a b

instance Eq Function where
  Function a _ _ _ == Function b _ _ _ = a == b

newtype Var = Var ((Int, Int), String)
  deriving (Eq, Ord, Show, Read)

type Program = [Function]

mapType :: GeneratedAbstractSyntax.Type -> Type
mapType GeneratedAbstractSyntax.TypeBit   = TypeBit
mapType GeneratedAbstractSyntax.TypeQbit  = TypeQbit
mapType GeneratedAbstractSyntax.TypeState  = TypeState
mapType GeneratedAbstractSyntax.TypeUnitary  = TypeUnitary
mapType GeneratedAbstractSyntax.TypeUnit  = TypeUnit
mapType (GeneratedAbstractSyntax.TypeNonLinear t) = TypeNonLinear (mapType t)
mapType (GeneratedAbstractSyntax.TypeFunction l r) = mapType l :->: mapType r
mapType (GeneratedAbstractSyntax.TypeSum l r) = mapType l :+: mapType r
mapType (GeneratedAbstractSyntax.TypeTensorProd l r) = mapType l :*: mapType r
mapType (GeneratedAbstractSyntax.TypeExp t i) = mapType t :**: i

mapBasisState :: GeneratedAbstractSyntax.BasisState -> BasisState
mapBasisState GeneratedAbstractSyntax.BasisStateZero = BasisStateZero
mapBasisState GeneratedAbstractSyntax.BasisStateOne = BasisStateOne
mapBasisState GeneratedAbstractSyntax.BasisStatePlus = BasisStatePlus
mapBasisState GeneratedAbstractSyntax.BasisStateMinus = BasisStateMinus
mapBasisState GeneratedAbstractSyntax.BasisStatePlusI = BasisStatePlusI
mapBasisState GeneratedAbstractSyntax.BasisStateMinusI = BasisStateMinusI

mapControlTerm :: Environment -> GeneratedAbstractSyntax.ControlTerm -> ControlTerm
mapControlTerm env (GeneratedAbstractSyntax.CtrlTerm term) = CtrlTerm (mapTerm env term)

mapControlTerms :: Environment -> GeneratedAbstractSyntax.ControlTerms -> ControlTerms
mapControlTerms env (GeneratedAbstractSyntax.CtrlTerms term []) = CtrlTerms (mapTerm env term) []
mapControlTerms env (GeneratedAbstractSyntax.CtrlTerms term [terms]) = CtrlTerms (mapTerm env term) (map (mapTerm env) [terms])
mapControlTerms _ _ = undefined

mapAngle :: GeneratedAbstractSyntax.Angle -> Angle
mapAngle (GeneratedAbstractSyntax.Angle value) = Angle value

mapBit :: GeneratedAbstractSyntax.Bit -> Bit
mapBit (GeneratedAbstractSyntax.BitValue 0) = BitZero
mapBit (GeneratedAbstractSyntax.BitValue 1) = BitOne
mapBit _ = undefined -- -- should not happen, TODO: add test for bit values in semantic analysis

mapGate :: GeneratedAbstractSyntax.Gate -> Gate
mapGate g = case g of
    GeneratedAbstractSyntax.GateH ->  GateH
    GeneratedAbstractSyntax.GateX -> GateX
    GeneratedAbstractSyntax.GateY -> GateY
    GeneratedAbstractSyntax.GateZ -> GateZ
    GeneratedAbstractSyntax.GateID -> GateID
    GeneratedAbstractSyntax.GateXRoot rt -> GateXRoot rt
    GeneratedAbstractSyntax.GateXRootDag rt -> GateXRootDag rt
    GeneratedAbstractSyntax.GateYRoot rt -> GateYRoot rt
    GeneratedAbstractSyntax.GateYRootDag rt -> GateYRootDag rt
    GeneratedAbstractSyntax.GateZRoot rt -> GateZRoot rt
    GeneratedAbstractSyntax.GateZRootDag rt -> GateZRootDag rt
    GeneratedAbstractSyntax.GateS -> GateS
    GeneratedAbstractSyntax.GateSDag -> GateSDag
    GeneratedAbstractSyntax.GateT -> GateT
    GeneratedAbstractSyntax.GateTDag -> GateTDag
    GeneratedAbstractSyntax.GateSqrtX -> GateSqrtX
    GeneratedAbstractSyntax.GateSqrtXDag -> GateSqrtXDag
    GeneratedAbstractSyntax.GateSqrtY -> GateSqrtY
    GeneratedAbstractSyntax.GateSqrtYDag -> GateSqrtYDag
    GeneratedAbstractSyntax.GateRxTheta angle -> GateRxTheta (mapAngle angle)
    GeneratedAbstractSyntax.GateRyTheta angle -> GateRyTheta (mapAngle angle)
    GeneratedAbstractSyntax.GateRzTheta angle -> GateRzTheta (mapAngle angle)
    GeneratedAbstractSyntax.GateU1 angle -> GateU1 (mapAngle angle)
    GeneratedAbstractSyntax.GateU2 angle1 angle2 -> GateU2 (mapAngle angle1) (mapAngle angle2)
    GeneratedAbstractSyntax.GateU3 angle1 angle2 angle3 -> GateU3 (mapAngle angle1) (mapAngle angle2) (mapAngle angle3)
    GeneratedAbstractSyntax.GateSwp -> GateSwp
    GeneratedAbstractSyntax.GateSqrtSwp -> GateSqrtSwp
    GeneratedAbstractSyntax.GateSqrtSwpDag -> GateSqrtSwpDag
    GeneratedAbstractSyntax.GateISwp -> GateISwp
    GeneratedAbstractSyntax.GateFSwp -> GateFSwp
    GeneratedAbstractSyntax.GateSwpTheta angle -> GateSwpTheta (mapAngle angle)
    GeneratedAbstractSyntax.GateSwpRt rt -> GateSwpRt rt
    GeneratedAbstractSyntax.GateSwpRtDag rt -> GateSwpRtDag rt
    GeneratedAbstractSyntax.GateQft n -> GateQft n
    GeneratedAbstractSyntax.GateQftDag n -> GateQftDag n

-- convert function to Church-style lambda abstractions
toLambdaAbstraction :: GeneratedAbstractSyntax.Type -> [GeneratedAbstractSyntax.Arg] ->  GeneratedAbstractSyntax.Term -> GeneratedAbstractSyntax.Term

toLambdaAbstraction (GeneratedAbstractSyntax.TypeNonLinear ftype) farg fbody = toLambdaAbstraction ftype farg fbody

toLambdaAbstraction (GeneratedAbstractSyntax.TypeFunction (GeneratedAbstractSyntax.TypeNonLinear ltype) rtype) (GeneratedAbstractSyntax.FunArg (GeneratedAbstractSyntax.Var var) : vars) fbody = 
  GeneratedAbstractSyntax.TermLambda (GeneratedAbstractSyntax.Lambda "\\") (GeneratedAbstractSyntax.Var var) ltype (toLambdaAbstraction rtype vars fbody)

toLambdaAbstraction (GeneratedAbstractSyntax.TypeFunction ltype (GeneratedAbstractSyntax.TypeNonLinear rtype)) (GeneratedAbstractSyntax.FunArg (GeneratedAbstractSyntax.Var var) : vars) fbody = 
  GeneratedAbstractSyntax.TermLambda (GeneratedAbstractSyntax.Lambda "\\") (GeneratedAbstractSyntax.Var var) ltype (toLambdaAbstraction rtype vars fbody)

toLambdaAbstraction (GeneratedAbstractSyntax.TypeFunction ltype rtype) (GeneratedAbstractSyntax.FunArg (GeneratedAbstractSyntax.Var var) : vars) fbody = 
  GeneratedAbstractSyntax.TermLambda (GeneratedAbstractSyntax.Lambda "\\") (GeneratedAbstractSyntax.Var var) ltype (toLambdaAbstraction rtype vars fbody)

toLambdaAbstraction (GeneratedAbstractSyntax.TypeFunction _ _) [] fbody = fbody

toLambdaAbstraction ftype _ fbody = fbody

mapFunction :: GeneratedAbstractSyntax.FunctionDeclaration -> Function
mapFunction (GeneratedAbstractSyntax.FunDecl funType funDef) = Function fname (fline, fcol) (mapType ftype) term
   where
     (GeneratedAbstractSyntax.FunType var ftype) = funType
     (GeneratedAbstractSyntax.FunDef (GeneratedAbstractSyntax.Var fvar) fargs fbody) = funDef
     ((fline, fcol), fname) = fvar
     term = mapTerm Data.Map.empty $ toLambdaAbstraction ftype fargs fbody

mapVariable :: GeneratedAbstractSyntax.Var -> Var
mapVariable (GeneratedAbstractSyntax.Var ((l, c), var)) = Var ((l, c), var)

type Environment = Data.Map.Map String Integer

toTerm :: GeneratedAbstractSyntax.LetVariable -> GeneratedAbstractSyntax.Term
toTerm (GeneratedAbstractSyntax.LetVar var) = GeneratedAbstractSyntax.TermVariable var

toVariableName :: GeneratedAbstractSyntax.Var -> String
toVariableName (GeneratedAbstractSyntax.Var var) = snd var

toLetVariableName :: GeneratedAbstractSyntax.LetVariable -> String
toLetVariableName (GeneratedAbstractSyntax.LetVar var) = toVariableName var

-- Section: mapping terms --

mapTerm :: Environment -> GeneratedAbstractSyntax.Term -> Term
mapTerm _ (GeneratedAbstractSyntax.TermVariable (GeneratedAbstractSyntax.Var ((l, c), "new"))) = TermNew (l, c)
mapTerm _ (GeneratedAbstractSyntax.TermVariable (GeneratedAbstractSyntax.Var ((l, c), "measr"))) = TermMeasure (l, c)

mapTerm env (GeneratedAbstractSyntax.TermIfElse cond t f) = TermIfElse (mapTerm env cond) (mapTerm env t) (mapTerm env f)

mapTerm env (GeneratedAbstractSyntax.TermLetSingle var letEq letIn) = TermLetSingle (mapTerm env letEq) (mapTerm inEnv letIn)
  where inEnv = Data.Map.insert (toLetVariableName var) 0 (Data.Map.map succ env)

mapTerm env (GeneratedAbstractSyntax.TermLetSugarSingle var letEq letIn) = TermLetSugarSingle (mapTerm env letEq) (mapTerm inEnv letIn)
  where inEnv = Data.Map.insert (toLetVariableName var) 0 (Data.Map.map succ env)

mapTerm env (GeneratedAbstractSyntax.TermLetMultiple x [] letEq letIn) = TermLetMultiple (mapTerm env letEq) (mapTerm letEnv letIn)
  where letEnv = updateEnv x [] env
mapTerm env (GeneratedAbstractSyntax.TermLetMultiple x (y:ys) letEq letIn) = TermLetMultiple (mapTerm env letEq) (mapTerm letEnv letIn)
  where letEnv = updateEnv x (y:ys) env

mapTerm env (GeneratedAbstractSyntax.TermLetSugarMultiple x [] letEq letIn) = TermLetSugarMultiple (mapTerm env letEq) (mapTerm letEnv letIn)
  where letEnv = updateEnv x [] env
mapTerm env (GeneratedAbstractSyntax.TermLetSugarMultiple x (y:ys) letEq letIn) = TermLetSugarMultiple (mapTerm env letEq) (mapTerm letEnv letIn)
  where letEnv = updateEnv x (y:ys) env

mapTerm env (GeneratedAbstractSyntax.TermQuantumCtrlGate (GeneratedAbstractSyntax.CtrlTerm term) (GeneratedAbstractSyntax.CtrlBasisState basisState)) =
    TermQuantumCtrlGate (mapTerm env term) (mapBasisState basisState)
mapTerm env (GeneratedAbstractSyntax.TermQuantumCtrlsGate (GeneratedAbstractSyntax.CtrlTerms term terms) (GeneratedAbstractSyntax.CtrlBasisStates basisState basisStates)) =
    TermQuantumCtrlsGate (mapTerm env term : map (mapTerm env) terms) (mapBasisState basisState : map mapBasisState basisStates)
mapTerm env (GeneratedAbstractSyntax.TermClassicCtrlGate (GeneratedAbstractSyntax.CtrlTerm term) (GeneratedAbstractSyntax.CtrlBit ctrlBit)) =
    TermClassicCtrlGate (mapTerm env term) ctrlBit
mapTerm env (GeneratedAbstractSyntax.TermClassicCtrlsGate (GeneratedAbstractSyntax.CtrlTerms term terms) (GeneratedAbstractSyntax.CtrlBits ctrlBit ctrlBits)) =
    TermClassicCtrlsGate (mapTerm env term : map (mapTerm env) terms) (ctrlBit : ctrlBits)

mapTerm env (GeneratedAbstractSyntax.TermApply l r) = TermApply (mapTerm env l) (mapTerm env r)
mapTerm env (GeneratedAbstractSyntax.TermDollar l r) = TermDollar (mapTerm env l) (mapTerm env r)
mapTerm env (GeneratedAbstractSyntax.TermCompose l r) = TermCompose (mapTerm env l) (mapTerm env r)
mapTerm env (GeneratedAbstractSyntax.TermVariable var) = case Data.Map.lookup varName env of
    Just int -> TermBoundVariable int
    Nothing  -> TermFreeVariable varName
  where
    varName = toVariableName var

mapTerm env (GeneratedAbstractSyntax.TermTuple (GeneratedAbstractSyntax.Tupl term terms)) = foldr1 TermTuple $ map (mapTerm env) (term:terms)

mapTerm env (GeneratedAbstractSyntax.TermLambda _ var typ term) = TermLambda (mapType typ) (mapTerm envUpdated term)
  where envUpdated = Data.Map.insert (toVariableName var) 0 (Data.Map.map succ env)

mapTerm _ (GeneratedAbstractSyntax.TermBasisState bs) = TermBasisState (mapBasisState bs)
mapTerm _ (GeneratedAbstractSyntax.TermGate gate) = TermGate (mapGate gate)
mapTerm _ (GeneratedAbstractSyntax.TermBit bit) = TermBit $ mapBit bit
mapTerm _ GeneratedAbstractSyntax.TermUnit = TermUnit

updateEnv :: GeneratedAbstractSyntax.LetVariable -> [GeneratedAbstractSyntax.LetVariable] -> Environment -> Environment
updateEnv x [] env = Data.Map.insert (toLetVariableName x) 0 (Data.Map.map succ env)
updateEnv x (y:ys) env = updateEnv y ys (updateEnv x [] env)

-- Done mapping terms --

mapProgram :: GeneratedAbstractSyntax.Program -> Program
mapProgram (GeneratedAbstractSyntax.ProgDef functions) = map mapFunction functions

runAstToIastConverter :: GeneratedAbstractSyntax.Program -> Either String Program
runAstToIastConverter program = if substring "error" programString then Left programString else Right mappedProgram
    where
      mappedProgram = mapProgram program
      programString = show mappedProgram

parseAndPrintTreeFromString :: String -> String
parseAndPrintTreeFromString str = case pProgram (myLexer str) of
    Left str -> errorWithoutStackTrace str
    Right program -> printTree program

parseAndPrintTreeFromFile :: FilePath -> IO String
parseAndPrintTreeFromFile path = parseAndPrintTreeFromString <$> readFile path

-- some utility functions, but there must be a better way to do this ..

substring :: String -> String -> Bool
substring (_:_) [] = False
substring xs ys
    | prefix xs ys = True
    | substring xs (tail ys) = True
    | otherwise = False

prefix :: String -> String -> Bool
prefix [] _ = True
prefix (_:_) [] = False
prefix (x:xs) (y:ys) = (x == y) && prefix xs ys