-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module LambdaQ.Par
  ( happyError
  , myLexer
  , pType1
  , pType
  , pAngle
  , pControlState
  , pControl
  , pListControl
  , pGate
  , pLetVariable
  , pListLetVariable
  , pTuple
  , pListTerm
  , pBit
  , pTerm3
  , pTerm2
  , pTerm1
  , pTerm
  , pArg
  , pListArg
  , pFunction
  , pFunDeclaration
  , pListFunDeclaration
  , pProgram
  ) where

import Prelude

import qualified LambdaQ.Abs
import LambdaQ.Lex

}

%name pType1 Type1
%name pType Type
%name pAngle Angle
%name pControlState ControlState
%name pControl Control
%name pListControl ListControl
%name pGate Gate
%name pLetVariable LetVariable
%name pListLetVariable ListLetVariable
%name pTuple Tuple
%name pListTerm ListTerm
%name pBit Bit
%name pTerm3 Term3
%name pTerm2 Term2
%name pTerm1 Term1
%name pTerm Term
%name pArg Arg
%name pListArg ListArg
%name pFunction Function
%name pFunDeclaration FunDeclaration
%name pListFunDeclaration ListFunDeclaration
%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'              { PT _ (TS _ 1)           }
  '$'              { PT _ (TS _ 2)           }
  '('              { PT _ (TS _ 3)           }
  '()'             { PT _ (TS _ 4)           }
  ')'              { PT _ (TS _ 5)           }
  '*'              { PT _ (TS _ 6)           }
  '+'              { PT _ (TS _ 7)           }
  '+i'             { PT _ (TS _ 8)           }
  ','              { PT _ (TS _ 9)           }
  '-'              { PT _ (TS _ 10)          }
  '->'             { PT _ (TS _ 11)          }
  '-i'             { PT _ (TS _ 12)          }
  '.'              { PT _ (TS _ 13)          }
  '0'              { PT _ (TS _ 14)          }
  '1'              { PT _ (TS _ 15)          }
  '='              { PT _ (TS _ 16)          }
  'Bit'            { PT _ (TS _ 17)          }
  'Ctrl'           { PT _ (TS _ 18)          }
  'FSwap'          { PT _ (TS _ 19)          }
  'H'              { PT _ (TS _ 20)          }
  'I'              { PT _ (TS _ 21)          }
  'ISwap'          { PT _ (TS _ 22)          }
  'Qbit'           { PT _ (TS _ 23)          }
  'RootSwap'       { PT _ (TS _ 24)          }
  'RootSwapDagger' { PT _ (TS _ 25)          }
  'RootX'          { PT _ (TS _ 26)          }
  'RootXDagger'    { PT _ (TS _ 27)          }
  'RootY'          { PT _ (TS _ 28)          }
  'RootYDagger'    { PT _ (TS _ 29)          }
  'RootZ'          { PT _ (TS _ 30)          }
  'RootZDagger'    { PT _ (TS _ 31)          }
  'RxTheta'        { PT _ (TS _ 32)          }
  'RyTheta'        { PT _ (TS _ 33)          }
  'RzTheta'        { PT _ (TS _ 34)          }
  'S'              { PT _ (TS _ 35)          }
  'SDagger'        { PT _ (TS _ 36)          }
  'SqrtSwap'       { PT _ (TS _ 37)          }
  'SqrtSwapDagger' { PT _ (TS _ 38)          }
  'SqrtX'          { PT _ (TS _ 39)          }
  'SqrtXDagger'    { PT _ (TS _ 40)          }
  'SqrtY'          { PT _ (TS _ 41)          }
  'SqrtYDagger'    { PT _ (TS _ 42)          }
  'Swap'           { PT _ (TS _ 43)          }
  'T'              { PT _ (TS _ 44)          }
  'TDagger'        { PT _ (TS _ 45)          }
  'U1'             { PT _ (TS _ 46)          }
  'U2'             { PT _ (TS _ 47)          }
  'U3'             { PT _ (TS _ 48)          }
  'X'              { PT _ (TS _ 49)          }
  'Y'              { PT _ (TS _ 50)          }
  'Z'              { PT _ (TS _ 51)          }
  'case'           { PT _ (TS _ 52)          }
  'else'           { PT _ (TS _ 53)          }
  'if'             { PT _ (TS _ 54)          }
  'in'             { PT _ (TS _ 55)          }
  'let'            { PT _ (TS _ 56)          }
  'of'             { PT _ (TS _ 57)          }
  'then'           { PT _ (TS _ 58)          }
  L_doubl          { PT _ (TD $$)            }
  L_integ          { PT _ (TI $$)            }
  L_GateGeneric    { PT _ (T_GateGeneric $$) }
  L_Var            { PT _ (T_Var _)          }
  L_FunVariable    { PT _ (T_FunVariable _)  }
  L_Lambda         { PT _ (T_Lambda _)       }

%%

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

GateGeneric :: { LambdaQ.Abs.GateGeneric }
GateGeneric  : L_GateGeneric { LambdaQ.Abs.GateGeneric $1 }

Var :: { LambdaQ.Abs.Var }
Var  : L_Var { LambdaQ.Abs.Var (mkPosToken $1) }

FunVariable :: { LambdaQ.Abs.FunVariable }
FunVariable  : L_FunVariable { LambdaQ.Abs.FunVariable (mkPosToken $1) }

Lambda :: { LambdaQ.Abs.Lambda }
Lambda  : L_Lambda { LambdaQ.Abs.Lambda (mkPosToken $1) }

Type1 :: { LambdaQ.Abs.Type }
Type1
  : 'Bit' { LambdaQ.Abs.TypeBit }
  | 'Qbit' { LambdaQ.Abs.TypeQbit }
  | '()' { LambdaQ.Abs.TypeUnit }
  | '!' Type1 { LambdaQ.Abs.TypeExp $2 }
  | '(' Type ')' { $2 }

Type :: { LambdaQ.Abs.Type }
Type
  : Type1 '*' Type { LambdaQ.Abs.TypeTens $1 $3 }
  | Type1 '->' Type { LambdaQ.Abs.TypeFunc $1 $3 }
  | Type1 { $1 }

Angle :: { LambdaQ.Abs.Angle }
Angle : Double { LambdaQ.Abs.AAngl $1 }

ControlState :: { LambdaQ.Abs.ControlState }
ControlState
  : '0' { LambdaQ.Abs.CStateZero }
  | '1' { LambdaQ.Abs.CStateOne }
  | '+' { LambdaQ.Abs.CStatePlus }
  | '-' { LambdaQ.Abs.CStateMinus }
  | '+i' { LambdaQ.Abs.CStateIPlus }
  | '-i' { LambdaQ.Abs.CStateIMinus }

Control :: { LambdaQ.Abs.Control }
Control : 'Ctrl' Integer ControlState { LambdaQ.Abs.CCtrl $2 $3 }

ListControl :: { [LambdaQ.Abs.Control] }
ListControl
  : Control { (:[]) $1 } | Control ',' ListControl { (:) $1 $3 }

Gate :: { LambdaQ.Abs.Gate }
Gate
  : 'H' ListControl { LambdaQ.Abs.GH $2 }
  | 'X' ListControl { LambdaQ.Abs.GX $2 }
  | 'Y' ListControl { LambdaQ.Abs.GY $2 }
  | 'Z' ListControl { LambdaQ.Abs.GZ $2 }
  | 'I' ListControl { LambdaQ.Abs.GI $2 }
  | 'RootX' Integer ListControl { LambdaQ.Abs.GXRt $2 $3 }
  | 'RootXDagger' Integer ListControl { LambdaQ.Abs.GXRtDag $2 $3 }
  | 'RootY' Integer ListControl { LambdaQ.Abs.GYRt $2 $3 }
  | 'RootYDagger' Integer ListControl { LambdaQ.Abs.GYRtDag $2 $3 }
  | 'RootZ' Integer ListControl { LambdaQ.Abs.GZRt $2 $3 }
  | 'RootZDagger' Integer ListControl { LambdaQ.Abs.GZRtDag $2 $3 }
  | 'S' ListControl { LambdaQ.Abs.GS $2 }
  | 'SDagger' ListControl { LambdaQ.Abs.GSDag $2 }
  | 'T' ListControl { LambdaQ.Abs.GT $2 }
  | 'TDagger' ListControl { LambdaQ.Abs.GTDag $2 }
  | 'SqrtX' ListControl { LambdaQ.Abs.GSqrtX $2 }
  | 'SqrtXDagger' ListControl { LambdaQ.Abs.GSqrtXDag $2 }
  | 'SqrtY' ListControl { LambdaQ.Abs.GSqrtY $2 }
  | 'SqrtYDagger' ListControl { LambdaQ.Abs.GSqrtYDag $2 }
  | 'RxTheta' Angle ListControl { LambdaQ.Abs.GRxTheta $2 $3 }
  | 'RyTheta' Angle ListControl { LambdaQ.Abs.GRyTheta $2 $3 }
  | 'RzTheta' Angle ListControl { LambdaQ.Abs.GRzTheta $2 $3 }
  | 'U1' Angle ListControl { LambdaQ.Abs.GU1 $2 $3 }
  | 'U2' Angle Angle ListControl { LambdaQ.Abs.GU2 $2 $3 $4 }
  | 'U3' Angle Angle Angle ListControl { LambdaQ.Abs.GU3 $2 $3 $4 $5 }
  | 'Swap' ListControl { LambdaQ.Abs.GSwp $2 }
  | 'SqrtSwap' ListControl { LambdaQ.Abs.GSqrtSwp $2 }
  | 'SqrtSwapDagger' ListControl { LambdaQ.Abs.GSqrtSwpDag $2 }
  | 'ISwap' ListControl { LambdaQ.Abs.GISwp $2 }
  | 'FSwap' ListControl { LambdaQ.Abs.GFSwp $2 }
  | 'RootSwap' Integer ListControl { LambdaQ.Abs.GSwpRt $2 $3 }
  | 'RootSwapDagger' Integer ListControl { LambdaQ.Abs.GSwpRtDag $2 $3 }
  | GateGeneric { LambdaQ.Abs.GGeneric $1 }

LetVariable :: { LambdaQ.Abs.LetVariable }
LetVariable : Var { LambdaQ.Abs.LVar $1 }

ListLetVariable :: { [LambdaQ.Abs.LetVariable] }
ListLetVariable
  : LetVariable { (:[]) $1 }
  | LetVariable ',' ListLetVariable { (:) $1 $3 }

Tuple :: { LambdaQ.Abs.Tuple }
Tuple : '(' Term ',' ListTerm ')' { LambdaQ.Abs.Tup $2 $4 }

ListTerm :: { [LambdaQ.Abs.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

Bit :: { LambdaQ.Abs.Bit }
Bit : Integer { LambdaQ.Abs.BBit $1 }

Term3 :: { LambdaQ.Abs.Term }
Term3
  : Var { LambdaQ.Abs.TVar $1 }
  | Bit { LambdaQ.Abs.TBit $1 }
  | Gate { LambdaQ.Abs.TGate $1 }
  | Tuple { LambdaQ.Abs.TTup $1 }
  | '()' { LambdaQ.Abs.TUnit }
  | '(' Term ')' { $2 }

Term2 :: { LambdaQ.Abs.Term }
Term2 : Term2 Term3 { LambdaQ.Abs.TApp $1 $2 } | Term3 { $1 }

Term1 :: { LambdaQ.Abs.Term }
Term1
  : 'if' Term 'then' Term 'else' Term { LambdaQ.Abs.TIfEl $2 $4 $6 }
  | 'let' '(' LetVariable ',' ListLetVariable ')' '=' Term 'in' Term { LambdaQ.Abs.TLet $3 $5 $8 $10 }
  | 'case' Term 'of' Term '->' Var Term '->' Var { LambdaQ.Abs.TCase $2 $4 $6 $7 $9 }
  | Lambda FunVariable Type '.' Term { LambdaQ.Abs.TLmbd $1 $2 $3 $5 }
  | Term2 '$' Term1 { LambdaQ.Abs.TDollr $1 $3 }
  | Term2 { $1 }

Term :: { LambdaQ.Abs.Term }
Term : Term1 { $1 }

Arg :: { LambdaQ.Abs.Arg }
Arg : Var { LambdaQ.Abs.FunArg $1 }

ListArg :: { [LambdaQ.Abs.Arg] }
ListArg : {- empty -} { [] } | Arg ListArg { (:) $1 $2 }

Function :: { LambdaQ.Abs.Function }
Function : Var ListArg '=' Term { LambdaQ.Abs.FunDef $1 $2 $4 }

FunDeclaration :: { LambdaQ.Abs.FunDeclaration }
FunDeclaration
  : FunVariable Type Function { LambdaQ.Abs.FunDecl $1 $2 $3 }

ListFunDeclaration :: { [LambdaQ.Abs.FunDeclaration] }
ListFunDeclaration
  : {- empty -} { [] }
  | FunDeclaration ListFunDeclaration { (:) $1 $2 }

Program :: { LambdaQ.Abs.Program }
Program : ListFunDeclaration { LambdaQ.Abs.ProgDef $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

