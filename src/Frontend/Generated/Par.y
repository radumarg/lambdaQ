-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module LambdaQ.Par
  ( happyError
  , myLexer
  , pType1
  , pType
  , pAngle
  , pControlState
  , pControl
  , pListControl
  , pGate
  , pLetVariable
  , pListLetVariable
  , pTuple
  , pListTerm
  , pBit
  , pTerm3
  , pTerm2
  , pTerm1
  , pTerm
  , pArg
  , pListArg
  , pFunction
  , pFunDeclaration
  , pListFunDeclaration
  , pProgram
  ) where

import Prelude

import qualified LambdaQ.Abs
import LambdaQ.Lex

}

%name pType1 Type1
%name pType Type
%name pAngle Angle
%name pControlState ControlState
%name pControl Control
%name pListControl ListControl
%name pGate Gate
%name pLetVariable LetVariable
%name pListLetVariable ListLetVariable
%name pTuple Tuple
%name pListTerm ListTerm
%name pBit Bit
%name pTerm3 Term3
%name pTerm2 Term2
%name pTerm1 Term1
%name pTerm Term
%name pArg Arg
%name pListArg ListArg
%name pFunction Function
%name pFunDeclaration FunDeclaration
%name pListFunDeclaration ListFunDeclaration
%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'              { PT _ (TS _ 1)          }
  '$'              { PT _ (TS _ 2)          }
  '('              { PT _ (TS _ 3)          }
  '()'             { PT _ (TS _ 4)          }
  ')'              { PT _ (TS _ 5)          }
  '*'              { PT _ (TS _ 6)          }
  '+'              { PT _ (TS _ 7)          }
  '+i'             { PT _ (TS _ 8)          }
  ','              { PT _ (TS _ 9)          }
  '-'              { PT _ (TS _ 10)         }
  '->'             { PT _ (TS _ 11)         }
  '-i'             { PT _ (TS _ 12)         }
  '.'              { PT _ (TS _ 13)         }
  '0'              { PT _ (TS _ 14)         }
  '1'              { PT _ (TS _ 15)         }
  '='              { PT _ (TS _ 16)         }
  'Bit'            { PT _ (TS _ 17)         }
  'Ctrl'           { PT _ (TS _ 18)         }
  'FSwap'          { PT _ (TS _ 19)         }
  'H'              { PT _ (TS _ 20)         }
  'I'              { PT _ (TS _ 21)         }
  'ISwap'          { PT _ (TS _ 22)         }
  'Qbit'           { PT _ (TS _ 23)         }
  'RxTheta'        { PT _ (TS _ 24)         }
  'RyTheta'        { PT _ (TS _ 25)         }
  'RzTheta'        { PT _ (TS _ 26)         }
  'S'              { PT _ (TS _ 27)         }
  'SDagger'        { PT _ (TS _ 28)         }
  'SqrtSwap'       { PT _ (TS _ 29)         }
  'Swap'           { PT _ (TS _ 30)         }
  'SwapRoot'       { PT _ (TS _ 31)         }
  'SwapRootDagger' { PT _ (TS _ 32)         }
  'T'              { PT _ (TS _ 33)         }
  'TDagger'        { PT _ (TS _ 34)         }
  'U1'             { PT _ (TS _ 35)         }
  'U2'             { PT _ (TS _ 36)         }
  'U3'             { PT _ (TS _ 37)         }
  'V'              { PT _ (TS _ 38)         }
  'VDagger'        { PT _ (TS _ 39)         }
  'X'              { PT _ (TS _ 40)         }
  'XRoot'          { PT _ (TS _ 41)         }
  'XRootDagger'    { PT _ (TS _ 42)         }
  'Y'              { PT _ (TS _ 43)         }
  'YRoot'          { PT _ (TS _ 44)         }
  'YRootDagger'    { PT _ (TS _ 45)         }
  'Z'              { PT _ (TS _ 46)         }
  'ZRoot'          { PT _ (TS _ 47)         }
  'ZRootDagger'    { PT _ (TS _ 48)         }
  'case'           { PT _ (TS _ 49)         }
  'else'           { PT _ (TS _ 50)         }
  'h'              { PT _ (TS _ 51)         }
  'hDagger'        { PT _ (TS _ 52)         }
  'if'             { PT _ (TS _ 53)         }
  'in'             { PT _ (TS _ 54)         }
  'let'            { PT _ (TS _ 55)         }
  'of'             { PT _ (TS _ 56)         }
  'then'           { PT _ (TS _ 57)         }
  L_doubl          { PT _ (TD $$)           }
  L_integ          { PT _ (TI $$)           }
  L_Var            { PT _ (T_Var _)         }
  L_FunVariable    { PT _ (T_FunVariable _) }
  L_Lambda         { PT _ (T_Lambda _)      }

%%

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Var :: { LambdaQ.Abs.Var }
Var  : L_Var { LambdaQ.Abs.Var (mkPosToken $1) }

FunVariable :: { LambdaQ.Abs.FunVariable }
FunVariable  : L_FunVariable { LambdaQ.Abs.FunVariable (mkPosToken $1) }

Lambda :: { LambdaQ.Abs.Lambda }
Lambda  : L_Lambda { LambdaQ.Abs.Lambda (mkPosToken $1) }

Type1 :: { LambdaQ.Abs.Type }
Type1
  : 'Bit' { LambdaQ.Abs.TypeBit }
  | 'Qbit' { LambdaQ.Abs.TypeQbit }
  | '()' { LambdaQ.Abs.TypeUnit }
  | '!' Type1 { LambdaQ.Abs.TypeExp $2 }
  | '(' Type ')' { $2 }

Type :: { LambdaQ.Abs.Type }
Type
  : Type1 '*' Type { LambdaQ.Abs.TypeTens $1 $3 }
  | Type1 '->' Type { LambdaQ.Abs.TypeFunc $1 $3 }
  | Type1 { $1 }

Angle :: { LambdaQ.Abs.Angle }
Angle : Double { LambdaQ.Abs.AAngl $1 }

ControlState :: { LambdaQ.Abs.ControlState }
ControlState
  : '0' { LambdaQ.Abs.CStateZero }
  | '1' { LambdaQ.Abs.CStateOne }
  | '+' { LambdaQ.Abs.CStatePlus }
  | '-' { LambdaQ.Abs.CStateMinus }
  | '+i' { LambdaQ.Abs.CStateIPlus }
  | '-i' { LambdaQ.Abs.CStateIMinus }

Control :: { LambdaQ.Abs.Control }
Control : 'Ctrl' Integer ControlState { LambdaQ.Abs.CCtrl $2 $3 }

ListControl :: { [LambdaQ.Abs.Control] }
ListControl
  : Control { (:[]) $1 } | Control ',' ListControl { (:) $1 $3 }

Gate :: { LambdaQ.Abs.Gate }
Gate
  : 'H' ListControl { LambdaQ.Abs.GH $2 }
  | 'X' ListControl { LambdaQ.Abs.GX $2 }
  | 'Y' ListControl { LambdaQ.Abs.GY $2 }
  | 'Z' ListControl { LambdaQ.Abs.GZ $2 }
  | 'I' ListControl { LambdaQ.Abs.GI $2 }
  | 'XRoot' ListControl { LambdaQ.Abs.GXRt $2 }
  | 'XRootDagger' ListControl { LambdaQ.Abs.GXRtDag $2 }
  | 'YRoot' ListControl { LambdaQ.Abs.GYRt $2 }
  | 'YRootDagger' ListControl { LambdaQ.Abs.GYRtDag $2 }
  | 'ZRoot' ListControl { LambdaQ.Abs.GZRt $2 }
  | 'ZRootDagger' ListControl { LambdaQ.Abs.GZRtDag $2 }
  | 'S' ListControl { LambdaQ.Abs.GS $2 }
  | 'SDagger' ListControl { LambdaQ.Abs.GSDag $2 }
  | 'T' ListControl { LambdaQ.Abs.GT $2 }
  | 'TDagger' ListControl { LambdaQ.Abs.GTDag $2 }
  | 'V' ListControl { LambdaQ.Abs.GV $2 }
  | 'VDagger' ListControl { LambdaQ.Abs.GVDag $2 }
  | 'h' ListControl { LambdaQ.Abs.Gh $2 }
  | 'hDagger' ListControl { LambdaQ.Abs.GhDag $2 }
  | 'RxTheta' Angle ListControl { LambdaQ.Abs.GRxTheta $2 $3 }
  | 'RyTheta' Angle ListControl { LambdaQ.Abs.GRyTheta $2 $3 }
  | 'RzTheta' Angle ListControl { LambdaQ.Abs.GRzTheta $2 $3 }
  | 'U1' Angle ListControl { LambdaQ.Abs.GU1 $2 $3 }
  | 'U2' Angle Angle ListControl { LambdaQ.Abs.GU2 $2 $3 $4 }
  | 'U3' Angle Angle Angle ListControl { LambdaQ.Abs.GU3 $2 $3 $4 $5 }
  | 'Swap' ListControl { LambdaQ.Abs.GSWP $2 }
  | 'SqrtSwap' ListControl { LambdaQ.Abs.GSQRTSWP $2 }
  | 'ISwap' ListControl { LambdaQ.Abs.GISWP $2 }
  | 'FSwap' ListControl { LambdaQ.Abs.GFSWP $2 }
  | 'SwapRoot' ListControl { LambdaQ.Abs.GSWPRt $2 }
  | 'SwapRootDagger' ListControl { LambdaQ.Abs.GSWPRtDag $2 }

LetVariable :: { LambdaQ.Abs.LetVariable }
LetVariable : Var { LambdaQ.Abs.LVar $1 }

ListLetVariable :: { [LambdaQ.Abs.LetVariable] }
ListLetVariable
  : LetVariable { (:[]) $1 }
  | LetVariable ',' ListLetVariable { (:) $1 $3 }

Tuple :: { LambdaQ.Abs.Tuple }
Tuple : '(' Term ',' ListTerm ')' { LambdaQ.Abs.Tup $2 $4 }

ListTerm :: { [LambdaQ.Abs.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

Bit :: { LambdaQ.Abs.Bit }
Bit : Integer { LambdaQ.Abs.BBit $1 }

Term3 :: { LambdaQ.Abs.Term }
Term3
  : Var { LambdaQ.Abs.TVar $1 }
  | Bit { LambdaQ.Abs.TBit $1 }
  | Gate { LambdaQ.Abs.TGate $1 }
  | Tuple { LambdaQ.Abs.TTup $1 }
  | '()' { LambdaQ.Abs.TUnit }
  | '(' Term ')' { $2 }

Term2 :: { LambdaQ.Abs.Term }
Term2 : Term2 Term3 { LambdaQ.Abs.TApp $1 $2 } | Term3 { $1 }

Term1 :: { LambdaQ.Abs.Term }
Term1
  : 'if' Term 'then' Term 'else' Term { LambdaQ.Abs.TIfEl $2 $4 $6 }
  | 'let' '(' LetVariable ',' ListLetVariable ')' '=' Term 'in' Term { LambdaQ.Abs.TLet $3 $5 $8 $10 }
  | 'case' Term 'of' Term '->' Var Term '->' Var { LambdaQ.Abs.TCase $2 $4 $6 $7 $9 }
  | Lambda FunVariable Type '.' Term { LambdaQ.Abs.TLmbd $1 $2 $3 $5 }
  | Term2 '$' Term1 { LambdaQ.Abs.TDollr $1 $3 }
  | Term2 { $1 }

Term :: { LambdaQ.Abs.Term }
Term : Term1 { $1 }

Arg :: { LambdaQ.Abs.Arg }
Arg : Var { LambdaQ.Abs.FunArg $1 }

ListArg :: { [LambdaQ.Abs.Arg] }
ListArg : {- empty -} { [] } | Arg ListArg { (:) $1 $2 }

Function :: { LambdaQ.Abs.Function }
Function : Var ListArg '=' Term { LambdaQ.Abs.FunDef $1 $2 $4 }

FunDeclaration :: { LambdaQ.Abs.FunDeclaration }
FunDeclaration
  : FunVariable Type Function { LambdaQ.Abs.FunDecl $1 $2 $3 }

ListFunDeclaration :: { [LambdaQ.Abs.FunDeclaration] }
ListFunDeclaration
  : {- empty -} { [] }
  | FunDeclaration ListFunDeclaration { (:) $1 $2 }

Program :: { LambdaQ.Abs.Program }
Program : ListFunDeclaration { LambdaQ.Abs.ProgDef $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

