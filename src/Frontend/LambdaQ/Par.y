-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Frontend.LambdaQ.Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Frontend.LambdaQ.Abs
import Frontend.LambdaQ.Lex

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'             { PT _ (TS _ 1)      }
  '$'             { PT _ (TS _ 2)      }
  '('             { PT _ (TS _ 3)      }
  '()'            { PT _ (TS _ 4)      }
  ')'             { PT _ (TS _ 5)      }
  '*'             { PT _ (TS _ 6)      }
  '**'            { PT _ (TS _ 7)      }
  '+'             { PT _ (TS _ 8)      }
  ','             { PT _ (TS _ 9)      }
  '->'            { PT _ (TS _ 10)     }
  '.'             { PT _ (TS _ 11)     }
  '::'            { PT _ (TS _ 12)     }
  ';'             { PT _ (TS _ 13)     }
  '<-'            { PT _ (TS _ 14)     }
  '='             { PT _ (TS _ 15)     }
  '@+'            { PT _ (TS _ 16)     }
  '@+i'           { PT _ (TS _ 17)     }
  '@-'            { PT _ (TS _ 18)     }
  '@-i'           { PT _ (TS _ 19)     }
  '@0'            { PT _ (TS _ 20)     }
  '@1'            { PT _ (TS _ 21)     }
  'Bit'           { PT _ (TS _ 22)     }
  'FSWAP'         { PT _ (TS _ 23)     }
  'H'             { PT _ (TS _ 24)     }
  'ID'            { PT _ (TS _ 25)     }
  'ISWAP'         { PT _ (TS _ 26)     }
  'Qbit'          { PT _ (TS _ 27)     }
  'ROOT_SWAP'     { PT _ (TS _ 28)     }
  'ROOT_SWAP_DAG' { PT _ (TS _ 29)     }
  'ROOT_X'        { PT _ (TS _ 30)     }
  'ROOT_X_DAG'    { PT _ (TS _ 31)     }
  'ROOT_Y'        { PT _ (TS _ 32)     }
  'ROOT_Y_DAG'    { PT _ (TS _ 33)     }
  'ROOT_Z'        { PT _ (TS _ 34)     }
  'ROOT_Z_DAG'    { PT _ (TS _ 35)     }
  'RX'            { PT _ (TS _ 36)     }
  'RY'            { PT _ (TS _ 37)     }
  'RZ'            { PT _ (TS _ 38)     }
  'S'             { PT _ (TS _ 39)     }
  'SQRT_SWAP'     { PT _ (TS _ 40)     }
  'SQRT_SWAP_DAG' { PT _ (TS _ 41)     }
  'SQRT_X'        { PT _ (TS _ 42)     }
  'SQRT_X_DAG'    { PT _ (TS _ 43)     }
  'SQRT_Y'        { PT _ (TS _ 44)     }
  'SQRT_Y_DAG'    { PT _ (TS _ 45)     }
  'SWAP'          { PT _ (TS _ 46)     }
  'SWAP_THETA'    { PT _ (TS _ 47)     }
  'S_DAG'         { PT _ (TS _ 48)     }
  'State'         { PT _ (TS _ 49)     }
  'T'             { PT _ (TS _ 50)     }
  'T_DAG'         { PT _ (TS _ 51)     }
  'U1'            { PT _ (TS _ 52)     }
  'U2'            { PT _ (TS _ 53)     }
  'U3'            { PT _ (TS _ 54)     }
  'Unitary'       { PT _ (TS _ 55)     }
  'X'             { PT _ (TS _ 56)     }
  'Y'             { PT _ (TS _ 57)     }
  'Z'             { PT _ (TS _ 58)     }
  '['             { PT _ (TS _ 59)     }
  ']'             { PT _ (TS _ 60)     }
  'case'          { PT _ (TS _ 61)     }
  'ctrl'          { PT _ (TS _ 62)     }
  'else'          { PT _ (TS _ 63)     }
  'if'            { PT _ (TS _ 64)     }
  'in'            { PT _ (TS _ 65)     }
  'let'           { PT _ (TS _ 66)     }
  'of'            { PT _ (TS _ 67)     }
  'then'          { PT _ (TS _ 68)     }
  'with'          { PT _ (TS _ 69)     }
  '{'             { PT _ (TS _ 70)     }
  '}'             { PT _ (TS _ 71)     }
  L_doubl         { PT _ (TD $$)       }
  L_integ         { PT _ (TI $$)       }
  L_Var           { PT _ (T_Var _)     }
  L_Lambda        { PT _ (T_Lambda $$) }

%%

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Var :: { Frontend.LambdaQ.Abs.Var }
Var  : L_Var { Frontend.LambdaQ.Abs.Var (mkPosToken $1) }

Lambda :: { Frontend.LambdaQ.Abs.Lambda }
Lambda  : L_Lambda { Frontend.LambdaQ.Abs.Lambda $1 }

Program :: { Frontend.LambdaQ.Abs.Program }
Program
  : ListFunctionDeclaration { Frontend.LambdaQ.Abs.ProgDef $1 }

Type3 :: { Frontend.LambdaQ.Abs.Type }
Type3
  : 'Bit' { Frontend.LambdaQ.Abs.TypeBit }
  | 'Qbit' { Frontend.LambdaQ.Abs.TypeQbit }
  | 'State' { Frontend.LambdaQ.Abs.TypeState }
  | 'Unitary' { Frontend.LambdaQ.Abs.TypeUnitary }
  | '()' { Frontend.LambdaQ.Abs.TypeUnit }
  | '(' Type ')' { $2 }

Type2 :: { Frontend.LambdaQ.Abs.Type }
Type2
  : '!' Type3 { Frontend.LambdaQ.Abs.TypeNonLin $2 }
  | Type3 '**' Integer { Frontend.LambdaQ.Abs.TypeExp $1 $3 }
  | Type3 { $1 }

Type1 :: { Frontend.LambdaQ.Abs.Type }
Type1
  : Type2 '+' Type1 { Frontend.LambdaQ.Abs.TypeSum $1 $3 }
  | Type2 '*' Type1 { Frontend.LambdaQ.Abs.TypeTensr $1 $3 }
  | Type2 { $1 }

Type :: { Frontend.LambdaQ.Abs.Type }
Type
  : Type1 '->' Type { Frontend.LambdaQ.Abs.TypeFunc $1 $3 }
  | Type1 { $1 }

Angle :: { Frontend.LambdaQ.Abs.Angle }
Angle : Double { Frontend.LambdaQ.Abs.Angle $1 }

BasisState :: { Frontend.LambdaQ.Abs.BasisState }
BasisState
  : '@0' { Frontend.LambdaQ.Abs.BasisStateZero }
  | '@1' { Frontend.LambdaQ.Abs.BasisStateOne }
  | '@+' { Frontend.LambdaQ.Abs.BasisStatePlus }
  | '@-' { Frontend.LambdaQ.Abs.BasisStateMinus }
  | '@+i' { Frontend.LambdaQ.Abs.BasisStatePlusI }
  | '@-i' { Frontend.LambdaQ.Abs.BasisStateMinusI }

Bit :: { Frontend.LambdaQ.Abs.Bit }
Bit : Integer { Frontend.LambdaQ.Abs.BitValue $1 }

Gate :: { Frontend.LambdaQ.Abs.Gate }
Gate
  : 'H' { Frontend.LambdaQ.Abs.GateH }
  | 'X' { Frontend.LambdaQ.Abs.GateX }
  | 'Y' { Frontend.LambdaQ.Abs.GateY }
  | 'Z' { Frontend.LambdaQ.Abs.GateZ }
  | 'ID' { Frontend.LambdaQ.Abs.GateID }
  | 'ROOT_X' Integer { Frontend.LambdaQ.Abs.GateXRt $2 }
  | 'ROOT_X_DAG' Integer { Frontend.LambdaQ.Abs.GateXRtDag $2 }
  | 'ROOT_Y' Integer { Frontend.LambdaQ.Abs.GateYRt $2 }
  | 'ROOT_Y_DAG' Integer { Frontend.LambdaQ.Abs.GateYRtDag $2 }
  | 'ROOT_Z' Integer { Frontend.LambdaQ.Abs.GateZRt $2 }
  | 'ROOT_Z_DAG' Integer { Frontend.LambdaQ.Abs.GateZRtDag $2 }
  | 'S' { Frontend.LambdaQ.Abs.GateS }
  | 'S_DAG' { Frontend.LambdaQ.Abs.GateSDag }
  | 'T' { Frontend.LambdaQ.Abs.GateT }
  | 'T_DAG' { Frontend.LambdaQ.Abs.GateTDag }
  | 'SQRT_X' { Frontend.LambdaQ.Abs.GateSqrtX }
  | 'SQRT_X_DAG' { Frontend.LambdaQ.Abs.GateSqrtXDag }
  | 'SQRT_Y' { Frontend.LambdaQ.Abs.GateSqrtY }
  | 'SQRT_Y_DAG' { Frontend.LambdaQ.Abs.GateSqrtYDag }
  | 'RX' Angle { Frontend.LambdaQ.Abs.GateRxTheta $2 }
  | 'RY' Angle { Frontend.LambdaQ.Abs.GateRyTheta $2 }
  | 'RZ' Angle { Frontend.LambdaQ.Abs.GateRzTheta $2 }
  | 'U1' Angle { Frontend.LambdaQ.Abs.GateU1 $2 }
  | 'U2' '(' Angle ',' Angle ')' { Frontend.LambdaQ.Abs.GateU2 $3 $5 }
  | 'U3' '(' Angle ',' Angle ',' Angle ')' { Frontend.LambdaQ.Abs.GateU3 $3 $5 $7 }
  | 'SWAP' { Frontend.LambdaQ.Abs.GateSwp }
  | 'SQRT_SWAP' { Frontend.LambdaQ.Abs.GateSqrtSwp }
  | 'SQRT_SWAP_DAG' { Frontend.LambdaQ.Abs.GateSqrtSwpDag }
  | 'ISWAP' { Frontend.LambdaQ.Abs.GateISwp }
  | 'FSWAP' { Frontend.LambdaQ.Abs.GateFSwp }
  | 'SWAP_THETA' Angle { Frontend.LambdaQ.Abs.GateSwpTheta $2 }
  | 'ROOT_SWAP' Integer { Frontend.LambdaQ.Abs.GateSwpRt $2 }
  | 'ROOT_SWAP_DAG' Integer { Frontend.LambdaQ.Abs.GateSwpRtDag $2 }

ControlBasisState :: { Frontend.LambdaQ.Abs.ControlBasisState }
ControlBasisState
  : '[' BasisState ']' { Frontend.LambdaQ.Abs.CtrlBasisState $2 }

ControlBasisStates :: { Frontend.LambdaQ.Abs.ControlBasisStates }
ControlBasisStates
  : '[' BasisState ',' ListBasisState ']' { Frontend.LambdaQ.Abs.CtrlBasisStates $2 $4 }

ListBasisState :: { [Frontend.LambdaQ.Abs.BasisState] }
ListBasisState
  : BasisState { (:[]) $1 }
  | BasisState ',' ListBasisState { (:) $1 $3 }

ControlBit :: { Frontend.LambdaQ.Abs.ControlBit }
ControlBit : '[' Integer ']' { Frontend.LambdaQ.Abs.CtrlBit $2 }

ControlBits :: { Frontend.LambdaQ.Abs.ControlBits }
ControlBits
  : '[' Integer ',' ListInteger ']' { Frontend.LambdaQ.Abs.CtrlBits $2 $4 }

ListInteger :: { [Integer] }
ListInteger
  : Integer { (:[]) $1 } | Integer ',' ListInteger { (:) $1 $3 }

Tuple :: { Frontend.LambdaQ.Abs.Tuple }
Tuple
  : '(' Term ',' ListTerm ')' { Frontend.LambdaQ.Abs.Tupl $2 $4 }

ControlTerm :: { Frontend.LambdaQ.Abs.ControlTerm }
ControlTerm : '[' Term ']' { Frontend.LambdaQ.Abs.CtrlTerm $2 }

ControlTerms :: { Frontend.LambdaQ.Abs.ControlTerms }
ControlTerms
  : '[' Term ',' ListTerm ']' { Frontend.LambdaQ.Abs.CtrlTerms $2 $4 }

ListTerm :: { [Frontend.LambdaQ.Abs.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

Term1 :: { Frontend.LambdaQ.Abs.Term }
Term1
  : 'if' Term 'then' Term 'else' Term { Frontend.LambdaQ.Abs.TermIfElse $2 $4 $6 }
  | 'let' '{' LetVariable '=' Term '}' 'in' Term { Frontend.LambdaQ.Abs.TermLetSingle $3 $5 $8 }
  | 'let' '{' '(' LetVariable ',' ListLetVariable ')' '=' Term '}' 'in' Term { Frontend.LambdaQ.Abs.TermLetMultiple $4 $6 $9 $12 }
  | LetVariable '<-' Term ';' Term { Frontend.LambdaQ.Abs.TermLetSugarSingle $1 $3 $5 }
  | LetVariable ',' ListLetVariable '<-' Term ';' Term { Frontend.LambdaQ.Abs.TermLetSugarMultiple $1 $3 $5 $7 }
  | 'case' Term 'of' CaseExpression ListCaseExpression { Frontend.LambdaQ.Abs.TermCase $2 $4 $5 }
  | Lambda FunctionType '.' Term { Frontend.LambdaQ.Abs.TermLambda $1 $2 $4 }
  | Term2 '$' Term1 { Frontend.LambdaQ.Abs.TermDollar $1 $3 }
  | Term2 { $1 }

Term2 :: { Frontend.LambdaQ.Abs.Term }
Term2
  : 'with' ControlTerm 'ctrl' ControlBasisState { Frontend.LambdaQ.Abs.TermQuantumCtrlGate $2 $4 }
  | 'with' ControlTerms 'ctrl' ControlBasisStates { Frontend.LambdaQ.Abs.TermQuantumCtrlsGate $2 $4 }
  | 'with' ControlTerm 'ctrl' ControlBit { Frontend.LambdaQ.Abs.TermClassicCtrlGate $2 $4 }
  | 'with' ControlTerms 'ctrl' ControlBits { Frontend.LambdaQ.Abs.TermClassicCtrlsGate $2 $4 }
  | Term2 Term3 { Frontend.LambdaQ.Abs.TermApply $1 $2 }
  | Term2 '.' Term3 { Frontend.LambdaQ.Abs.TermCompose $1 $3 }
  | Term3 { $1 }

Term3 :: { Frontend.LambdaQ.Abs.Term }
Term3
  : Var { Frontend.LambdaQ.Abs.TermVariable $1 }
  | BasisState { Frontend.LambdaQ.Abs.TermBasisState $1 }
  | Gate { Frontend.LambdaQ.Abs.TermGate $1 }
  | Tuple { Frontend.LambdaQ.Abs.TermTuple $1 }
  | '()' { Frontend.LambdaQ.Abs.TermUnit }
  | '(' Term ')' { $2 }

Term :: { Frontend.LambdaQ.Abs.Term }
Term : Term1 { $1 }

LetVariable :: { Frontend.LambdaQ.Abs.LetVariable }
LetVariable : Var { Frontend.LambdaQ.Abs.LetVar $1 }

ListLetVariable :: { [Frontend.LambdaQ.Abs.LetVariable] }
ListLetVariable
  : {- empty -} { [] }
  | LetVariable { (:[]) $1 }
  | LetVariable ',' ListLetVariable { (:) $1 $3 }

CaseExpression :: { Frontend.LambdaQ.Abs.CaseExpression }
CaseExpression
  : Term '->' Var { Frontend.LambdaQ.Abs.CaseExp $1 $3 }

ListCaseExpression :: { [Frontend.LambdaQ.Abs.CaseExpression] }
ListCaseExpression
  : CaseExpression { (:[]) $1 }
  | CaseExpression ListCaseExpression { (:) $1 $2 }

Arg :: { Frontend.LambdaQ.Abs.Arg }
Arg : Var { Frontend.LambdaQ.Abs.FunArg $1 }

ListArg :: { [Frontend.LambdaQ.Abs.Arg] }
ListArg : {- empty -} { [] } | Arg ListArg { (:) $1 $2 }

FunctionDefinition :: { Frontend.LambdaQ.Abs.FunctionDefinition }
FunctionDefinition
  : Var ListArg '=' Term { Frontend.LambdaQ.Abs.FunDef $1 $2 $4 }
  | FunctionDefinition ';' { $1 }

FunctionType :: { Frontend.LambdaQ.Abs.FunctionType }
FunctionType
  : Var '::' Type { Frontend.LambdaQ.Abs.FunType $1 $3 }
  | FunctionType ';' { $1 }

FunctionDeclaration :: { Frontend.LambdaQ.Abs.FunctionDeclaration }
FunctionDeclaration
  : FunctionType ';' FunctionDefinition ';' { Frontend.LambdaQ.Abs.FunDecl $1 $3 }

ListFunctionDeclaration :: { [Frontend.LambdaQ.Abs.FunctionDeclaration] }
ListFunctionDeclaration
  : {- empty -} { [] }
  | FunctionDeclaration ListFunctionDeclaration { (:) $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

