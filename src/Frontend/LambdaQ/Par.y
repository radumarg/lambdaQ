-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Frontend.LambdaQ.Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Frontend.LambdaQ.Abs
import Frontend.LambdaQ.Lex

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'             { PT _ (TS _ 1)        }
  '$'             { PT _ (TS _ 2)        }
  '('             { PT _ (TS _ 3)        }
  '()'            { PT _ (TS _ 4)        }
  ')'             { PT _ (TS _ 5)        }
  '*'             { PT _ (TS _ 6)        }
  '**'            { PT _ (TS _ 7)        }
  ','             { PT _ (TS _ 8)        }
  '->'            { PT _ (TS _ 9)        }
  '::'            { PT _ (TS _ 10)       }
  ';'             { PT _ (TS _ 11)       }
  '='             { PT _ (TS _ 12)       }
  '@+'            { PT _ (TS _ 13)       }
  '@+i'           { PT _ (TS _ 14)       }
  '@-'            { PT _ (TS _ 15)       }
  '@-i'           { PT _ (TS _ 16)       }
  '@0'            { PT _ (TS _ 17)       }
  '@1'            { PT _ (TS _ 18)       }
  'Bit'           { PT _ (TS _ 19)       }
  'FSWAP'         { PT _ (TS _ 20)       }
  'H'             { PT _ (TS _ 21)       }
  'ID'            { PT _ (TS _ 22)       }
  'ISWAP'         { PT _ (TS _ 23)       }
  'Qbit'          { PT _ (TS _ 24)       }
  'ROOT_SWAP'     { PT _ (TS _ 25)       }
  'ROOT_SWAP_DAG' { PT _ (TS _ 26)       }
  'ROOT_X'        { PT _ (TS _ 27)       }
  'ROOT_X_DAG'    { PT _ (TS _ 28)       }
  'ROOT_Y'        { PT _ (TS _ 29)       }
  'ROOT_Y_DAG'    { PT _ (TS _ 30)       }
  'ROOT_Z'        { PT _ (TS _ 31)       }
  'ROOT_Z_DAG'    { PT _ (TS _ 32)       }
  'RX'            { PT _ (TS _ 33)       }
  'RY'            { PT _ (TS _ 34)       }
  'RZ'            { PT _ (TS _ 35)       }
  'S'             { PT _ (TS _ 36)       }
  'SQRT_SWAP'     { PT _ (TS _ 37)       }
  'SQRT_SWAP_DAG' { PT _ (TS _ 38)       }
  'SQRT_X'        { PT _ (TS _ 39)       }
  'SQRT_X_DAG'    { PT _ (TS _ 40)       }
  'SQRT_Y'        { PT _ (TS _ 41)       }
  'SQRT_Y_DAG'    { PT _ (TS _ 42)       }
  'SWAP'          { PT _ (TS _ 43)       }
  'SWAP_THETA'    { PT _ (TS _ 44)       }
  'S_DAG'         { PT _ (TS _ 45)       }
  'T'             { PT _ (TS _ 46)       }
  'T_DAG'         { PT _ (TS _ 47)       }
  'U1'            { PT _ (TS _ 48)       }
  'U2'            { PT _ (TS _ 49)       }
  'U3'            { PT _ (TS _ 50)       }
  'X'             { PT _ (TS _ 51)       }
  'Y'             { PT _ (TS _ 52)       }
  'Z'             { PT _ (TS _ 53)       }
  '['             { PT _ (TS _ 54)       }
  ']'             { PT _ (TS _ 55)       }
  'case'          { PT _ (TS _ 56)       }
  'else'          { PT _ (TS _ 57)       }
  'gate'          { PT _ (TS _ 58)       }
  'if'            { PT _ (TS _ 59)       }
  'in'            { PT _ (TS _ 60)       }
  'let'           { PT _ (TS _ 61)       }
  'of'            { PT _ (TS _ 62)       }
  'then'          { PT _ (TS _ 63)       }
  'with-ctrl'     { PT _ (TS _ 64)       }
  '{'             { PT _ (TS _ 65)       }
  '}'             { PT _ (TS _ 66)       }
  L_doubl         { PT _ (TD $$)         }
  L_integ         { PT _ (TI $$)         }
  L_GateIdent     { PT _ (T_GateIdent _) }
  L_Var           { PT _ (T_Var _)       }
  L_Lambda        { PT _ (T_Lambda $$)   }
  L_Bit           { PT _ (T_Bit _)       }

%%

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

GateIdent :: { Frontend.LambdaQ.Abs.GateIdent }
GateIdent  : L_GateIdent { Frontend.LambdaQ.Abs.GateIdent (mkPosToken $1) }

Var :: { Frontend.LambdaQ.Abs.Var }
Var  : L_Var { Frontend.LambdaQ.Abs.Var (mkPosToken $1) }

Lambda :: { Frontend.LambdaQ.Abs.Lambda }
Lambda  : L_Lambda { Frontend.LambdaQ.Abs.Lambda $1 }

Bit :: { Frontend.LambdaQ.Abs.Bit }
Bit  : L_Bit { Frontend.LambdaQ.Abs.Bit (mkPosToken $1) }

Program :: { Frontend.LambdaQ.Abs.Program }
Program
  : ListFunctionDeclaration { Frontend.LambdaQ.Abs.ProgDef $1 }

Type3 :: { Frontend.LambdaQ.Abs.Type }
Type3
  : 'Bit' { Frontend.LambdaQ.Abs.TypeBit }
  | 'Qbit' { Frontend.LambdaQ.Abs.TypeQbit }
  | '()' { Frontend.LambdaQ.Abs.TypeUnit }
  | '(' Type ')' { $2 }

Type2 :: { Frontend.LambdaQ.Abs.Type }
Type2
  : '!' Type3 { Frontend.LambdaQ.Abs.TypeNonLin $2 } | Type3 { $1 }

Type1 :: { Frontend.LambdaQ.Abs.Type }
Type1
  : Type2 '**' Integer { Frontend.LambdaQ.Abs.TypeExp $1 $3 }
  | Type2 '*' Type1 { Frontend.LambdaQ.Abs.TypeTensr $1 $3 }
  | Type2 { $1 }

Type :: { Frontend.LambdaQ.Abs.Type }
Type
  : Type1 '->' Type { Frontend.LambdaQ.Abs.TypeFunc $1 $3 }
  | Type1 { $1 }

Angle :: { Frontend.LambdaQ.Abs.Angle }
Angle : Double { Frontend.LambdaQ.Abs.AAngl $1 }

ControlState :: { Frontend.LambdaQ.Abs.ControlState }
ControlState
  : '@0' { Frontend.LambdaQ.Abs.CStateZero }
  | '@1' { Frontend.LambdaQ.Abs.CStateOne }
  | '@+' { Frontend.LambdaQ.Abs.CStatePlus }
  | '@-' { Frontend.LambdaQ.Abs.CStateMinus }
  | '@+i' { Frontend.LambdaQ.Abs.CStatePlusI }
  | '@-i' { Frontend.LambdaQ.Abs.CStateMinusI }

Control :: { Frontend.LambdaQ.Abs.Control }
Control : Term ControlState { Frontend.LambdaQ.Abs.CCtrl $1 $2 }

ListControl :: { [Frontend.LambdaQ.Abs.Control] }
ListControl
  : Control { (:[]) $1 } | Control ',' ListControl { (:) $1 $3 }

Gate :: { Frontend.LambdaQ.Abs.Gate }
Gate
  : 'H' { Frontend.LambdaQ.Abs.GateH }
  | 'X' { Frontend.LambdaQ.Abs.GateX }
  | 'Y' { Frontend.LambdaQ.Abs.GateY }
  | 'Z' { Frontend.LambdaQ.Abs.GateZ }
  | 'ID' { Frontend.LambdaQ.Abs.GateI }
  | 'ROOT_X' Integer { Frontend.LambdaQ.Abs.GateXRt $2 }
  | 'ROOT_X_DAG' Integer { Frontend.LambdaQ.Abs.GateXRtDag $2 }
  | 'ROOT_Y' Integer { Frontend.LambdaQ.Abs.GateYRt $2 }
  | 'ROOT_Y_DAG' Integer { Frontend.LambdaQ.Abs.GateYRtDag $2 }
  | 'ROOT_Z' Integer { Frontend.LambdaQ.Abs.GateZRt $2 }
  | 'ROOT_Z_DAG' Integer { Frontend.LambdaQ.Abs.GateZRtDag $2 }
  | 'S' { Frontend.LambdaQ.Abs.GateS }
  | 'S_DAG' { Frontend.LambdaQ.Abs.GateSDag }
  | 'T' { Frontend.LambdaQ.Abs.GateT }
  | 'T_DAG' { Frontend.LambdaQ.Abs.GateTDag }
  | 'SQRT_X' { Frontend.LambdaQ.Abs.GateSqrtX }
  | 'SQRT_X_DAG' { Frontend.LambdaQ.Abs.GateSqrtXDag }
  | 'SQRT_Y' { Frontend.LambdaQ.Abs.GateSqrtY }
  | 'SQRT_Y_DAG' { Frontend.LambdaQ.Abs.GateSqrtYDag }
  | 'RX' Angle { Frontend.LambdaQ.Abs.GateRxTheta $2 }
  | 'RY' Angle { Frontend.LambdaQ.Abs.GateRyTheta $2 }
  | 'RZ' Angle { Frontend.LambdaQ.Abs.GateRzTheta $2 }
  | 'U1' Angle { Frontend.LambdaQ.Abs.GateU1 $2 }
  | 'U2' '(' Angle ',' Angle ')' { Frontend.LambdaQ.Abs.GateU2 $3 $5 }
  | 'U3' '(' Angle ',' Angle ',' Angle ')' { Frontend.LambdaQ.Abs.GateU3 $3 $5 $7 }
  | 'SWAP' { Frontend.LambdaQ.Abs.GateSwp }
  | 'SQRT_SWAP' { Frontend.LambdaQ.Abs.GateSqrtSwp }
  | 'SQRT_SWAP_DAG' { Frontend.LambdaQ.Abs.GateSqrtSwpDag }
  | 'ISWAP' { Frontend.LambdaQ.Abs.GateISwp }
  | 'FSWAP' { Frontend.LambdaQ.Abs.GateFSwp }
  | 'SWAP_THETA' Angle { Frontend.LambdaQ.Abs.GateSwpTheta $2 }
  | 'ROOT_SWAP' Integer { Frontend.LambdaQ.Abs.GateSwpRt $2 }
  | 'ROOT_SWAP_DAG' Integer { Frontend.LambdaQ.Abs.GateSwpRtDag $2 }
  | GateIdent { Frontend.LambdaQ.Abs.GateGeneric $1 }

LetVariable :: { Frontend.LambdaQ.Abs.LetVariable }
LetVariable : Var { Frontend.LambdaQ.Abs.LetVar $1 }

ListLetVariable :: { [Frontend.LambdaQ.Abs.LetVariable] }
ListLetVariable
  : LetVariable { (:[]) $1 }
  | LetVariable ',' ListLetVariable { (:) $1 $3 }

LambdaVariable :: { Frontend.LambdaQ.Abs.LambdaVariable }
LambdaVariable : Var { Frontend.LambdaQ.Abs.LambdaVar $1 }

ListLambdaVariable :: { [Frontend.LambdaQ.Abs.LambdaVariable] }
ListLambdaVariable
  : {- empty -} { [] }
  | LambdaVariable ListLambdaVariable { (:) $1 $2 }

Tuple :: { Frontend.LambdaQ.Abs.Tuple }
Tuple
  : '(' Term ',' ListTerm ')' { Frontend.LambdaQ.Abs.Tup $2 $4 }

ListTerm :: { [Frontend.LambdaQ.Abs.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

Term3 :: { Frontend.LambdaQ.Abs.Term }
Term3
  : Var { Frontend.LambdaQ.Abs.TVar $1 }
  | Bit { Frontend.LambdaQ.Abs.TBit $1 }
  | Tuple { Frontend.LambdaQ.Abs.TTupl $1 }
  | '()' { Frontend.LambdaQ.Abs.TUnit }
  | '(' Term ')' { $2 }

Term1 :: { Frontend.LambdaQ.Abs.Term }
Term1
  : 'if' Term 'then' Term 'else' Term { Frontend.LambdaQ.Abs.TIfEls $2 $4 $6 }
  | 'let' '{' LetVariable '=' Term '}' 'in' Term { Frontend.LambdaQ.Abs.TLetOne $3 $5 $8 }
  | 'let' '{' '(' LetVariable ',' ListLetVariable ')' '=' Term '}' 'in' Term { Frontend.LambdaQ.Abs.TLetMany $4 $6 $9 $12 }
  | 'case' Term 'of' CaseExpression ListCaseExpression { Frontend.LambdaQ.Abs.TCase $2 $4 $5 }
  | Lambda LambdaVariable ListLambdaVariable '->' Term { Frontend.LambdaQ.Abs.TLambd $1 $2 $3 $5 }
  | Term2 '$' Term1 { Frontend.LambdaQ.Abs.TDollr $1 $3 }
  | 'gate' Gate Term { Frontend.LambdaQ.Abs.TGate $2 $3 }
  | 'gate' Gate Term 'with-ctrl' '[' ListControl ']' { Frontend.LambdaQ.Abs.TCtrlGate $2 $3 $6 }
  | Term2 { $1 }

Term2 :: { Frontend.LambdaQ.Abs.Term }
Term2
  : Term2 Term3 { Frontend.LambdaQ.Abs.TApp $1 $2 } | Term3 { $1 }

Term :: { Frontend.LambdaQ.Abs.Term }
Term : Term1 { $1 }

CaseExpression :: { Frontend.LambdaQ.Abs.CaseExpression }
CaseExpression
  : Term '->' Var { Frontend.LambdaQ.Abs.CaseExp $1 $3 }

ListCaseExpression :: { [Frontend.LambdaQ.Abs.CaseExpression] }
ListCaseExpression
  : CaseExpression { (:[]) $1 }
  | CaseExpression ListCaseExpression { (:) $1 $2 }

Arg :: { Frontend.LambdaQ.Abs.Arg }
Arg : Var { Frontend.LambdaQ.Abs.FunArg $1 }

ListArg :: { [Frontend.LambdaQ.Abs.Arg] }
ListArg : {- empty -} { [] } | Arg ListArg { (:) $1 $2 }

FunctionDefinition :: { Frontend.LambdaQ.Abs.FunctionDefinition }
FunctionDefinition
  : Var ListArg '=' Term { Frontend.LambdaQ.Abs.FunDef $1 $2 $4 }
  | FunctionDefinition ';' { $1 }

FunctionType :: { Frontend.LambdaQ.Abs.FunctionType }
FunctionType
  : Var '::' Type { Frontend.LambdaQ.Abs.FunType $1 $3 }
  | FunctionType ';' { $1 }

FunctionDeclaration :: { Frontend.LambdaQ.Abs.FunctionDeclaration }
FunctionDeclaration
  : FunctionType ';' FunctionDefinition ';' { Frontend.LambdaQ.Abs.FunDecl $1 $3 }

ListFunctionDeclaration :: { [Frontend.LambdaQ.Abs.FunctionDeclaration] }
ListFunctionDeclaration
  : {- empty -} { [] }
  | FunctionDeclaration ListFunctionDeclaration { (:) $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

