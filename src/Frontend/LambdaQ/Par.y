-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Frontend.LambdaQ.Par
  ( happyError
  , myLexer
  , pType1
  , pType
  , pAngle
  , pControlState
  , pControl
  , pListControl
  , pGate
  , pLetVariable
  , pListLetVariable
  , pTuple
  , pListTerm
  , pBit
  , pTerm3
  , pTerm2
  , pTerm1
  , pTerm
  , pArg
  , pListArg
  , pFunction
  , pFunDeclaration
  , pListFunDeclaration
  , pProgram
  ) where

import Prelude

import qualified Frontend.LambdaQ.Abs
import Frontend.LambdaQ.Lex

}

%name pType1 Type1
%name pType Type
%name pAngle Angle
%name pControlState ControlState
%name pControl Control
%name pListControl ListControl
%name pGate Gate
%name pLetVariable LetVariable
%name pListLetVariable ListLetVariable
%name pTuple Tuple
%name pListTerm ListTerm
%name pBit Bit
%name pTerm3 Term3
%name pTerm2 Term2
%name pTerm1 Term1
%name pTerm Term
%name pArg Arg
%name pListArg ListArg
%name pFunction Function
%name pFunDeclaration FunDeclaration
%name pListFunDeclaration ListFunDeclaration
%name pProgram Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'              { PT _ (TS _ 1)          }
  '$'              { PT _ (TS _ 2)          }
  '('              { PT _ (TS _ 3)          }
  '()'             { PT _ (TS _ 4)          }
  ')'              { PT _ (TS _ 5)          }
  '+'              { PT _ (TS _ 6)          }
  '+i'             { PT _ (TS _ 7)          }
  ','              { PT _ (TS _ 8)          }
  '-'              { PT _ (TS _ 9)          }
  '->'             { PT _ (TS _ 10)         }
  '-i'             { PT _ (TS _ 11)         }
  '.'              { PT _ (TS _ 12)         }
  '0'              { PT _ (TS _ 13)         }
  '1'              { PT _ (TS _ 14)         }
  ';'              { PT _ (TS _ 15)         }
  '='              { PT _ (TS _ 16)         }
  '><'             { PT _ (TS _ 17)         }
  'Bit'            { PT _ (TS _ 18)         }
  'Ctrl'           { PT _ (TS _ 19)         }
  'FSwap'          { PT _ (TS _ 20)         }
  'H'              { PT _ (TS _ 21)         }
  'I'              { PT _ (TS _ 22)         }
  'ISwap'          { PT _ (TS _ 23)         }
  'Qbit'           { PT _ (TS _ 24)         }
  'RootSwap'       { PT _ (TS _ 25)         }
  'RootSwapDagger' { PT _ (TS _ 26)         }
  'RootX'          { PT _ (TS _ 27)         }
  'RootXDagger'    { PT _ (TS _ 28)         }
  'RootY'          { PT _ (TS _ 29)         }
  'RootYDagger'    { PT _ (TS _ 30)         }
  'RootZ'          { PT _ (TS _ 31)         }
  'RootZDagger'    { PT _ (TS _ 32)         }
  'RxTheta'        { PT _ (TS _ 33)         }
  'RyTheta'        { PT _ (TS _ 34)         }
  'RzTheta'        { PT _ (TS _ 35)         }
  'S'              { PT _ (TS _ 36)         }
  'SDagger'        { PT _ (TS _ 37)         }
  'SqrtSwap'       { PT _ (TS _ 38)         }
  'SqrtSwapDagger' { PT _ (TS _ 39)         }
  'SqrtX'          { PT _ (TS _ 40)         }
  'SqrtXDagger'    { PT _ (TS _ 41)         }
  'SqrtY'          { PT _ (TS _ 42)         }
  'SqrtYDagger'    { PT _ (TS _ 43)         }
  'Swap'           { PT _ (TS _ 44)         }
  'T'              { PT _ (TS _ 45)         }
  'TDagger'        { PT _ (TS _ 46)         }
  'U1'             { PT _ (TS _ 47)         }
  'U2'             { PT _ (TS _ 48)         }
  'U3'             { PT _ (TS _ 49)         }
  'X'              { PT _ (TS _ 50)         }
  'Y'              { PT _ (TS _ 51)         }
  'Z'              { PT _ (TS _ 52)         }
  '^'              { PT _ (TS _ 53)         }
  'case'           { PT _ (TS _ 54)         }
  'else'           { PT _ (TS _ 55)         }
  'if'             { PT _ (TS _ 56)         }
  'in'             { PT _ (TS _ 57)         }
  'let'            { PT _ (TS _ 58)         }
  'of'             { PT _ (TS _ 59)         }
  'then'           { PT _ (TS _ 60)         }
  L_doubl          { PT _ (TD $$)           }
  L_integ          { PT _ (TI $$)           }
  L_GateIdent      { PT _ (T_GateIdent $$)  }
  L_Var            { PT _ (T_Var _)         }
  L_FunVariable    { PT _ (T_FunVariable _) }
  L_Lambda         { PT _ (T_Lambda _)      }

%%

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

GateIdent :: { Frontend.LambdaQ.Abs.GateIdent }
GateIdent  : L_GateIdent { Frontend.LambdaQ.Abs.GateIdent $1 }

Var :: { Frontend.LambdaQ.Abs.Var }
Var  : L_Var { Frontend.LambdaQ.Abs.Var (mkPosToken $1) }

FunVariable :: { Frontend.LambdaQ.Abs.FunVariable }
FunVariable  : L_FunVariable { Frontend.LambdaQ.Abs.FunVariable (mkPosToken $1) }

Lambda :: { Frontend.LambdaQ.Abs.Lambda }
Lambda  : L_Lambda { Frontend.LambdaQ.Abs.Lambda (mkPosToken $1) }

Type1 :: { Frontend.LambdaQ.Abs.Type }
Type1
  : 'Bit' { Frontend.LambdaQ.Abs.TypeBit }
  | 'Qbit' { Frontend.LambdaQ.Abs.TypeQbit }
  | '()' { Frontend.LambdaQ.Abs.TypeUnit }
  | '!' Type1 { Frontend.LambdaQ.Abs.TypeExp $2 }
  | Type1 '^' Integer { Frontend.LambdaQ.Abs.TypeTensrs $1 $3 }
  | '(' Type ')' { $2 }

Type :: { Frontend.LambdaQ.Abs.Type }
Type
  : Type1 '><' Type { Frontend.LambdaQ.Abs.TypeTensr $1 $3 }
  | Type1 '->' Type { Frontend.LambdaQ.Abs.TypeFunc $1 $3 }
  | Type1 { $1 }

Angle :: { Frontend.LambdaQ.Abs.Angle }
Angle : Double { Frontend.LambdaQ.Abs.AAngl $1 }

ControlState :: { Frontend.LambdaQ.Abs.ControlState }
ControlState
  : '0' { Frontend.LambdaQ.Abs.CStateZero }
  | '1' { Frontend.LambdaQ.Abs.CStateOne }
  | '+' { Frontend.LambdaQ.Abs.CStatePlus }
  | '-' { Frontend.LambdaQ.Abs.CStateMinus }
  | '+i' { Frontend.LambdaQ.Abs.CStateIPlus }
  | '-i' { Frontend.LambdaQ.Abs.CStateIMinus }

Control :: { Frontend.LambdaQ.Abs.Control }
Control
  : 'Ctrl' Integer ControlState { Frontend.LambdaQ.Abs.CCtrl $2 $3 }

ListControl :: { [Frontend.LambdaQ.Abs.Control] }
ListControl
  : Control { (:[]) $1 } | Control ',' ListControl { (:) $1 $3 }

Gate :: { Frontend.LambdaQ.Abs.Gate }
Gate
  : 'H' ListControl { Frontend.LambdaQ.Abs.GH $2 }
  | 'X' ListControl { Frontend.LambdaQ.Abs.GX $2 }
  | 'Y' ListControl { Frontend.LambdaQ.Abs.GY $2 }
  | 'Z' ListControl { Frontend.LambdaQ.Abs.GZ $2 }
  | 'I' ListControl { Frontend.LambdaQ.Abs.GI $2 }
  | 'RootX' Integer ListControl { Frontend.LambdaQ.Abs.GXRt $2 $3 }
  | 'RootXDagger' Integer ListControl { Frontend.LambdaQ.Abs.GXRtDag $2 $3 }
  | 'RootY' Integer ListControl { Frontend.LambdaQ.Abs.GYRt $2 $3 }
  | 'RootYDagger' Integer ListControl { Frontend.LambdaQ.Abs.GYRtDag $2 $3 }
  | 'RootZ' Integer ListControl { Frontend.LambdaQ.Abs.GZRt $2 $3 }
  | 'RootZDagger' Integer ListControl { Frontend.LambdaQ.Abs.GZRtDag $2 $3 }
  | 'S' ListControl { Frontend.LambdaQ.Abs.GS $2 }
  | 'SDagger' ListControl { Frontend.LambdaQ.Abs.GSDag $2 }
  | 'T' ListControl { Frontend.LambdaQ.Abs.GT $2 }
  | 'TDagger' ListControl { Frontend.LambdaQ.Abs.GTDag $2 }
  | 'SqrtX' ListControl { Frontend.LambdaQ.Abs.GSqrtX $2 }
  | 'SqrtXDagger' ListControl { Frontend.LambdaQ.Abs.GSqrtXDag $2 }
  | 'SqrtY' ListControl { Frontend.LambdaQ.Abs.GSqrtY $2 }
  | 'SqrtYDagger' ListControl { Frontend.LambdaQ.Abs.GSqrtYDag $2 }
  | 'RxTheta' Angle ListControl { Frontend.LambdaQ.Abs.GRxTheta $2 $3 }
  | 'RyTheta' Angle ListControl { Frontend.LambdaQ.Abs.GRyTheta $2 $3 }
  | 'RzTheta' Angle ListControl { Frontend.LambdaQ.Abs.GRzTheta $2 $3 }
  | 'U1' Angle ListControl { Frontend.LambdaQ.Abs.GU1 $2 $3 }
  | 'U2' Angle Angle ListControl { Frontend.LambdaQ.Abs.GU2 $2 $3 $4 }
  | 'U3' Angle Angle Angle ListControl { Frontend.LambdaQ.Abs.GU3 $2 $3 $4 $5 }
  | 'Swap' ListControl { Frontend.LambdaQ.Abs.GSwp $2 }
  | 'SqrtSwap' ListControl { Frontend.LambdaQ.Abs.GSqrtSwp $2 }
  | 'SqrtSwapDagger' ListControl { Frontend.LambdaQ.Abs.GSqrtSwpDag $2 }
  | 'ISwap' ListControl { Frontend.LambdaQ.Abs.GISwp $2 }
  | 'FSwap' ListControl { Frontend.LambdaQ.Abs.GFSwp $2 }
  | 'RootSwap' Integer ListControl { Frontend.LambdaQ.Abs.GSwpRt $2 $3 }
  | 'RootSwapDagger' Integer ListControl { Frontend.LambdaQ.Abs.GSwpRtDag $2 $3 }
  | GateIdent { Frontend.LambdaQ.Abs.GGate $1 }

LetVariable :: { Frontend.LambdaQ.Abs.LetVariable }
LetVariable : Var { Frontend.LambdaQ.Abs.LVar $1 }

ListLetVariable :: { [Frontend.LambdaQ.Abs.LetVariable] }
ListLetVariable
  : LetVariable { (:[]) $1 }
  | LetVariable ',' ListLetVariable { (:) $1 $3 }

Tuple :: { Frontend.LambdaQ.Abs.Tuple }
Tuple
  : '(' Term ',' ListTerm ')' { Frontend.LambdaQ.Abs.Tup $2 $4 }

ListTerm :: { [Frontend.LambdaQ.Abs.Term] }
ListTerm
  : Term { (:[]) $1 }
  | Term ',' ListTerm { (:) $1 $3 }
  | {- empty -} { [] }
  | Term ';' ListTerm { (:) $1 $3 }

Bit :: { Frontend.LambdaQ.Abs.Bit }
Bit : Integer { Frontend.LambdaQ.Abs.BBit $1 }

Term3 :: { Frontend.LambdaQ.Abs.Term }
Term3
  : Var { Frontend.LambdaQ.Abs.TVar $1 }
  | Bit { Frontend.LambdaQ.Abs.TBit $1 }
  | Gate { Frontend.LambdaQ.Abs.TGate $1 }
  | Tuple { Frontend.LambdaQ.Abs.TTup $1 }
  | '()' { Frontend.LambdaQ.Abs.TUnit }
  | '(' Term ')' { $2 }

Term2 :: { Frontend.LambdaQ.Abs.Term }
Term2
  : Term2 Term3 { Frontend.LambdaQ.Abs.TApp $1 $2 } | Term3 { $1 }

Term1 :: { Frontend.LambdaQ.Abs.Term }
Term1
  : 'if' Term 'then' Term 'else' Term { Frontend.LambdaQ.Abs.TIfEl $2 $4 $6 }
  | 'let' '(' LetVariable ',' ListLetVariable ')' '=' Term 'in' Term { Frontend.LambdaQ.Abs.TLet $3 $5 $8 $10 }
  | 'case' Term 'of' Term '->' Var Term '->' Var { Frontend.LambdaQ.Abs.TCase $2 $4 $6 $7 $9 }
  | Lambda FunVariable Type '.' Term { Frontend.LambdaQ.Abs.TLmbd $1 $2 $3 $5 }
  | Term2 '$' Term1 { Frontend.LambdaQ.Abs.TDollr $1 $3 }
  | Term2 { $1 }

Term :: { Frontend.LambdaQ.Abs.Term }
Term : Term1 { $1 }

Arg :: { Frontend.LambdaQ.Abs.Arg }
Arg : Var { Frontend.LambdaQ.Abs.FunArg $1 }

ListArg :: { [Frontend.LambdaQ.Abs.Arg] }
ListArg : {- empty -} { [] } | Arg ListArg { (:) $1 $2 }

Function :: { Frontend.LambdaQ.Abs.Function }
Function
  : Var ListArg '=' Term { Frontend.LambdaQ.Abs.FunDef $1 $2 $4 }

FunDeclaration :: { Frontend.LambdaQ.Abs.FunDeclaration }
FunDeclaration
  : FunVariable Type Function { Frontend.LambdaQ.Abs.FunDecl $1 $2 $3 }

ListFunDeclaration :: { [Frontend.LambdaQ.Abs.FunDeclaration] }
ListFunDeclaration
  : {- empty -} { [] }
  | FunDeclaration ListFunDeclaration { (:) $1 $2 }

Program :: { Frontend.LambdaQ.Abs.Program }
Program : ListFunDeclaration { Frontend.LambdaQ.Abs.ProgDef $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

