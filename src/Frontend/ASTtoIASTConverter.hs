-- This file contain the specification of the for the intermediate abstract syntax tree (IAST).
-- The intermediate abstract syntax tree hase a simpler syntax than the abstract syntax (AST)
-- generated by the parser and is easier to process by the type checker and the code generator:
--   *  functions to be be converted to lambda abstractions 
--   *  introduce De Bruijn indices for bound variables in lambda abstractions
--   *  BNFC generated AST terms to be converted into an intermediate abstract syntax tree terms
module Frontend.ASTtoIASTConverter (
  Function(..),
  Gate(..),
  mapProgram,
  Program,
  runAstToIastConverter,
  Term(..),
  Type(..),
) where

import qualified Frontend.LambdaQ.Abs as GeneratedAbstractSyntax
import qualified Data.Map

data Type =
   TypeBit             |
   TypeQbit            |
   TypeBool            |
   TypeInteger         |
   TypeUnit            |
   TypeList Type       |
   TypeNonLinear Type  |
   Type :->: Type      |
   Type :*: Type       |
   Type :**: Integer
  deriving (Eq, Ord, Read, Show)

infixr 1 :->:
infixr 3 :*:
infixr 4 :**:

data BoolValue = BoolValueTrue | BoolValueFalse
  deriving (Eq, Ord, Show, Read)

data IntegerExpression
    = ArithmExprMinus IntegerExpression
    | ArithmExprAdd IntegerExpression IntegerExpression
    | ArithmExprSub IntegerExpression IntegerExpression
    | ArithmExprMul IntegerExpression IntegerExpression
    | ArithmExprDiv IntegerExpression IntegerExpression
    | ArithmExprInt Integer
  deriving (Eq, Ord, Show, Read)

data BoolExpression
    = BoolExpressionAnd BoolExpression BoolExpression
    | BoolExpressionOr BoolExpression BoolExpression
    | BoolExpressionNot BoolExpression
    | BoolExpressionEq BoolExpression BoolExpression
    | BoolExpressionDif BoolExpression BoolExpression
    | BoolExpressionEqInt IntegerExpression IntegerExpression
    | BoolExpressionDifInt IntegerExpression IntegerExpression
    | BoolExpressionGt IntegerExpression IntegerExpression
    | BoolExpressionGe IntegerExpression IntegerExpression
    | BoolExpressionLt IntegerExpression IntegerExpression
    | BoolExpressionLe IntegerExpression IntegerExpression
    | BoolExpressionVal BoolValue
  deriving (Eq, Ord, Show, Read)

data List
    = ListNil
    | ListSingle Term
    | ListMultiple Term [Term]
    | ListExpressionAdd List List
    | ListCons Term List
  deriving (Eq, Ord, Show, Read)

data BasisState =
    BasisStateZero   |
    BasisStateOne    |
    BasisStatePlus   |
    BasisStateMinus  |
    BasisStatePlusI  |
    BasisStateMinusI
  deriving (Eq, Ord, Show, Read)

newtype ControlBasisState = CtrlBasisState BasisState
  deriving (Eq, Ord, Show, Read)

data ControlBasisStates = CtrlBasisStates BasisState [BasisState]
  deriving (Eq, Ord, Show, Read)

newtype Angle = Angle Double
  deriving (Eq, Ord, Show, Read)

data Bit = BitZero | BitOne
  deriving (Eq, Ord, Show, Read)

data Gate =
    GateH                      |
    GateX                      |
    GateY                      |
    GateZ                      |
    GateID                     |
    GateXRootInt Integer       |
    GateXRootVar Var           |
    GateXRootDagInt Integer    |
    GateXRootDagVar Var        |
    GateYRootInt Integer       |
    GateYRootVar Var           |
    GateYRootDagInt Integer    |
    GateYRootDagVar Var        |
    GateZRootInt Integer       |
    GateZRootVar Var           |
    GateZRootDagInt Integer    |
    GateZRootDagVar Var        |
    GateS                      |
    GateSDag                   |
    GateT                      |
    GateTDag                   |
    GateSqrtX                  |
    GateSqrtXDag               |
    GateSqrtY                  |
    GateSqrtYDag               |
    GateRxTheta Angle          |
    GateRyTheta Angle          |
    GateRzTheta Angle          |
    GateU1 Angle               |
    GateU2 Angle Angle         |
    GateU3 Angle Angle Angle   |
    GateSwp                    |
    GateSqrtSwp                |
    GateSqrtSwpDag             |
    GateISwp                   |
    GateFSwp                   |
    GateSwpTheta Angle         |
    GateSwpRtInt Integer       |
    GateSwpRtVar Var           |
    GateSwpRtDagInt Integer    |
    GateSwpRtDagVar Var        |
    GateQftInt Integer         |
    GateQftVar Var             |
    GateQftDagInt Integer      |
    GateQftDagVar Var
  deriving (Eq, Ord, Read, Show)

data Term =
    TermList List                                 |
    TermListElement List Integer                  |
    TermBoolExpression BoolExpression             |
    TermIntegerExpression IntegerExpression       |
    TermVariable Var                              |
    TermIfElse Term Term Term                     |
    TermLet [Var] Term Term                       |
    TermCase Term [Term]                          |
    TermLambda Type Term                          |
    TermGate Gate                                 |
    TermQuantumControlGate [Term] [BasisState]    |
    TermClassicControlGate [Term] [Bit]           |
    TermApply Term Term                           |
    TermDollar Term Term                          |
    TermCompose Term Term                         |
    TermNew  (Int, Int)                           |
    TermMeasure (Int, Int)                        |
    TermBasisState BasisState                     |
    TermTuple Term [Term]                         |
    TermBit Bit                                   |
    TermTensorProduct Term Term                   |
    TermUnit
  deriving (Eq, Ord, Read, Show)

newtype ControlTerm = CtrlTerm Term
  deriving (Eq, Ord, Show, Read)

data ControlTerms = CtrlTerms Term [Term]
  deriving (Eq, Ord, Show, Read)

data Function = Function String (Int, Int) Type Term
  deriving (Show, Read)

instance Ord Function where
  compare (Function a _ _ _) (Function b _ _ _) = compare a b

instance Eq Function where
  Function a _ _ _ == Function b _ _ _ = a == b

newtype Var = Var ((Int, Int), String)
  deriving (Eq, Ord, Show, Read)

type Program = [Function]

type Environment = Data.Map.Map String Integer

mapProgram :: GeneratedAbstractSyntax.Program -> Program
mapProgram (GeneratedAbstractSyntax.ProgDef functions) = map mapFunction functions

runAstToIastConverter :: GeneratedAbstractSyntax.Program -> Either String Program
runAstToIastConverter program = if substring "error" programString then Left programString else Right mappedProgram
    where
      mappedProgram = mapProgram program
      programString = show mappedProgram

mapType :: GeneratedAbstractSyntax.Type -> Type
mapType GeneratedAbstractSyntax.TypeBool = TypeBool
mapType GeneratedAbstractSyntax.TypeInteger = TypeInteger
mapType GeneratedAbstractSyntax.TypeBit = TypeBit
mapType GeneratedAbstractSyntax.TypeQbit = TypeQbit
mapType GeneratedAbstractSyntax.TypeUnit = TypeUnit
mapType (GeneratedAbstractSyntax.TypeNonLinear t) = TypeNonLinear (mapType t)
mapType (GeneratedAbstractSyntax.TypeFunction l r) = mapType l :->: mapType r
mapType (GeneratedAbstractSyntax.TypeTensorProd l r) = mapType l :*: mapType r
mapType (GeneratedAbstractSyntax.TypeExp t i) = mapType t :**: i
mapType (GeneratedAbstractSyntax.TypeList t) = TypeList (mapType t)

mapVariable :: GeneratedAbstractSyntax.Var -> Var
mapVariable (GeneratedAbstractSyntax.Var ((l, c), var)) = Var ((l, c), var)

mapBasisState :: GeneratedAbstractSyntax.BasisState -> BasisState
mapBasisState GeneratedAbstractSyntax.BasisStateZero = BasisStateZero
mapBasisState GeneratedAbstractSyntax.BasisStateOne = BasisStateOne
mapBasisState GeneratedAbstractSyntax.BasisStatePlus = BasisStatePlus
mapBasisState GeneratedAbstractSyntax.BasisStateMinus = BasisStateMinus
mapBasisState GeneratedAbstractSyntax.BasisStatePlusI = BasisStatePlusI
mapBasisState GeneratedAbstractSyntax.BasisStateMinusI = BasisStateMinusI

mapAngle :: GeneratedAbstractSyntax.Angle -> Angle
mapAngle (GeneratedAbstractSyntax.AngleValue value) = Angle value

mapGate :: GeneratedAbstractSyntax.Gate -> Gate
mapGate g = case g of
    GeneratedAbstractSyntax.GateH ->  GateH
    GeneratedAbstractSyntax.GateX -> GateX
    GeneratedAbstractSyntax.GateY -> GateY
    GeneratedAbstractSyntax.GateZ -> GateZ
    GeneratedAbstractSyntax.GateID -> GateID
    GeneratedAbstractSyntax.GateXRootInt rt -> GateXRootInt rt
    GeneratedAbstractSyntax.GateXRootVar rt -> GateXRootVar (mapVariable rt)
    GeneratedAbstractSyntax.GateXRootDagInt rt -> GateXRootDagInt rt
    GeneratedAbstractSyntax.GateXRootDagVar rt -> GateXRootDagVar (mapVariable rt)
    GeneratedAbstractSyntax.GateYRootInt rt -> GateYRootInt rt
    GeneratedAbstractSyntax.GateYRootVar rt -> GateYRootVar (mapVariable rt)
    GeneratedAbstractSyntax.GateYRootDagInt rt -> GateYRootDagInt rt
    GeneratedAbstractSyntax.GateYRootDagVar rt -> GateYRootDagVar (mapVariable rt)
    GeneratedAbstractSyntax.GateZRootInt rt -> GateZRootInt rt
    GeneratedAbstractSyntax.GateZRootVar rt -> GateZRootVar (mapVariable rt)
    GeneratedAbstractSyntax.GateZRootDagInt rt -> GateZRootDagInt rt
    GeneratedAbstractSyntax.GateZRootDagVar rt -> GateZRootDagVar (mapVariable rt)
    GeneratedAbstractSyntax.GateS -> GateS
    GeneratedAbstractSyntax.GateSDag -> GateSDag
    GeneratedAbstractSyntax.GateT -> GateT
    GeneratedAbstractSyntax.GateTDag -> GateTDag
    GeneratedAbstractSyntax.GateSqrtX -> GateSqrtX
    GeneratedAbstractSyntax.GateSqrtXDag -> GateSqrtXDag
    GeneratedAbstractSyntax.GateSqrtY -> GateSqrtY
    GeneratedAbstractSyntax.GateSqrtYDag -> GateSqrtYDag
    GeneratedAbstractSyntax.GateRxTheta angle -> GateRxTheta (mapAngle angle)
    GeneratedAbstractSyntax.GateRyTheta angle -> GateRyTheta (mapAngle angle)
    GeneratedAbstractSyntax.GateRzTheta angle -> GateRzTheta (mapAngle angle)
    GeneratedAbstractSyntax.GateU1 angle -> GateU1 (mapAngle angle)
    GeneratedAbstractSyntax.GateU2 angle1 angle2 -> GateU2 (mapAngle angle1) (mapAngle angle2)
    GeneratedAbstractSyntax.GateU3 angle1 angle2 angle3 -> GateU3 (mapAngle angle1) (mapAngle angle2) (mapAngle angle3)
    GeneratedAbstractSyntax.GateSwp -> GateSwp
    GeneratedAbstractSyntax.GateSqrtSwp -> GateSqrtSwp
    GeneratedAbstractSyntax.GateSqrtSwpDag -> GateSqrtSwpDag
    GeneratedAbstractSyntax.GateISwp -> GateISwp
    GeneratedAbstractSyntax.GateFSwp -> GateFSwp
    GeneratedAbstractSyntax.GateSwpTheta angle -> GateSwpTheta (mapAngle angle)
    GeneratedAbstractSyntax.GateSwpRtInt rt -> GateSwpRtInt rt
    GeneratedAbstractSyntax.GateSwpRtVar rt -> GateSwpRtVar (mapVariable rt)
    GeneratedAbstractSyntax.GateSwpRtDagInt rt -> GateSwpRtDagInt rt
    GeneratedAbstractSyntax.GateSwpRtDagVar rt -> GateSwpRtDagVar (mapVariable rt)
    GeneratedAbstractSyntax.GateQftInt n -> GateQftInt n
    GeneratedAbstractSyntax.GateQftVar n -> GateQftVar (mapVariable n)
    GeneratedAbstractSyntax.GateQftDagInt n -> GateQftDagInt n
    GeneratedAbstractSyntax.GateQftDagVar n -> GateQftDagVar (mapVariable n)
    GeneratedAbstractSyntax.GateUnknown3Angle {} -> undefined
    GeneratedAbstractSyntax.GateUnknown2Angle {}  -> undefined
    GeneratedAbstractSyntax.GateUnknown1Angle _ _  -> undefined
    GeneratedAbstractSyntax.GateUnknownInt _ _ -> undefined
    GeneratedAbstractSyntax.GateUnknownVar _ _ -> undefined
    GeneratedAbstractSyntax.GateUnknownSimple _ -> undefined

mapFunction :: GeneratedAbstractSyntax.FunctionDeclaration -> Function
mapFunction (GeneratedAbstractSyntax.FunDecl funType funDef) = Function fname (fline, fcol) (mapType ftype) term
   where
     (GeneratedAbstractSyntax.FunType _ ftype) = funType
     (GeneratedAbstractSyntax.FunDef (GeneratedAbstractSyntax.Var fvar) fargs fbody) = funDef
     ((fline, fcol), fname) = fvar
     term = mapTerm Data.Map.empty $ toLambdaAbstraction ftype fargs fbody

-- convert functions to Church-style lambda abstractions --

toLambdaAbstraction :: GeneratedAbstractSyntax.Type -> [GeneratedAbstractSyntax.Arg] ->  GeneratedAbstractSyntax.Term -> GeneratedAbstractSyntax.Term
toLambdaAbstraction = undefined

-- mapping terms --

mapTerm :: Environment -> GeneratedAbstractSyntax.Term -> Term
mapTerm = undefined

-- some utility functions --

substring :: String -> String -> Bool
substring (_:_) [] = False
substring xs ys
    | prefix xs ys = True
    | substring xs (tail ys) = True
    | otherwise = False

prefix :: String -> String -> Bool
prefix [] _ = True
prefix (_:_) [] = False
prefix (x:xs) (y:ys) = (x == y) && prefix xs ys